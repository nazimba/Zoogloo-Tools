# zgDynamiSkeleton
# Initial code generated by XSI SDK Wizard
# Executed Fri Jan 26 17:49:51 PST 2007 by ab
# 
# Tip: To add a command to this plug-in, right-click in the 
# script editor and choose Tools > Add Command.
# 
# Tip: To get help on a callback, highlight the callback name
# (for example, "Init", "Define", or "Execute") and press F1.
import win32com.client
from win32com.client import constants
from win32com.client import constants as c
from win32com.client.dynamic import Dispatch as dispatch

xsi = Application
log = xsi.logmessage

null = None
false = 0
true = 1

def XSILoadPlugin(in_reg):
	in_reg.Author = "andy"
	in_reg.Name = "zJiggle"
	in_reg.Email = ""
	in_reg.URL = ""
	in_reg.Major = 0
	in_reg.Minor = 1
	
	in_reg.RegisterOperator("zJiggleOp")
	
	in_reg.RegisterCommand("zApplyJiggleOp")
	in_reg.RegisterCommand("zJiggle")

	#RegistrationInsertionPoint - do not remove this line

	return true

def XSIUnloadPlugin(in_reg):
	strPluginName = in_reg.Name
	Application.LogMessage(str(strPluginName) + str(" has been unloaded."))
	return true


def zApplyJiggleOp_Init(ctxt):
	oCmd = ctxt.Source
	oCmd.Description = "Attaches a zJiggleOp"
	oCmd.SetFlag(constants.siNoLogging,false)

	oArgs = oCmd.Arguments
	oArgs.AddWithHandler("anchorObject", c.siArgHandlerSingleObj)
	oArgs.AddWithHandler("bobObject", c.siArgHandlerSingleObj)
	
	return true

def zApplyJiggleOp_Execute(anchorObject, bobObject):

	# pick the anchor object #
	if not anchorObject: 
		picker = xsi.PickElement(c.siGenericObjectFilter, 'Pick The Anchor Object')
		if not picker[0]:
			log('Cancelled.')
			return False
		else:
			anchorObject = picker[2]
			
	# pick the bob object #
	if not bobObject: 
		picker = xsi.PickElement(c.siGenericObjectFilter, 'Pick The Bob Object')
		if not picker[0]:
			log('Cancelled.')
			return False
		else:
			bobObject = picker[2]
			
	log('Anchor Object: %s' % anchorObject)
	log('Bob Object: %s' % bobObject)
	
	# calculate the default length #
	vSrc = XSIMath.CreateVector3()
	vDst = XSIMath.CreateVector3()
	vDelta = XSIMath.CreateVector3()
	bobObject.Kinematics.Global.Transform.GetTranslation(vDst)
	anchorObject.Kinematics.Global.Transform.GetTranslation(vSrc)
	vDelta.Sub(vSrc, vDst)
	log('Delta: %s' % vDelta.Length())

	# create the operator #
	newOp = XSIFactory.CreateObject('zJiggleOp')
	
	# set the default length #
	newOp.RestLength.Value = vDelta.Length()

	# add the ports #
	newOp.AddInputPort(anchorObject.kinematics.Global, 'springIn')
	newOp.AddInputPort(bobObject.kinematics.Global, 'bobIn')
	newOp.AddOutputPort(bobObject.kinematics.Global, 'bobOut')
	
	# connect the operator #
	newOp.Connect()
	xsi.InspectObj(newOp)

	return
	
			
def zJiggleOp_Define(ctxt):
	op = ctxt.Source
	
	# add the parameters #
	pdef = XSIFactory.CreateParamDef('RestLength', c.siDouble, 
			c.siClassifUnknown, c.siPersistable+c.siAnimatable, 'Rest Length',
			'', 3, 0, 1000000, 0.001, 10)
	param = op.AddParameter(pdef)
	pdef = XSIFactory.CreateParamDef('Mass', c.siDouble, 
			c.siClassifUnknown, c.siPersistable+c.siAnimatable, '',
			'', 1, 0, 1000000, 0.001, 10)
	param = op.AddParameter(pdef)
	pdef = XSIFactory.CreateParamDef('SpringStiffness', c.siDouble, 
			c.siClassifUnknown, c.siPersistable+c.siAnimatable, 
			'Spring Stiffness (k)',
			'Spring Coefficient', 1, 0, 1000000, 0.001, 10)
	param = op.AddParameter(pdef)
	pdef = XSIFactory.CreateParamDef('Gravity', c.siDouble, 
			c.siClassifUnknown, c.siPersistable+c.siAnimatable, '',
			'', 9.8, 0, 1000000, 0.001, 10)
	param = op.AddParameter(pdef)
	pdef = XSIFactory.CreateParamDef('Damping', c.siDouble, 
			c.siClassifUnknown, c.siPersistable+c.siAnimatable, '',
			'', 5, 0, 1000000, 0.001, 10)
	param = op.AddParameter(pdef)
	pdef = XSIFactory.CreateParamDef('ReactionTime', c.siDouble, 
			c.siClassifUnknown, c.siPersistable+c.siAnimatable, 
			'Reaction Time',
			'', 5, 0, 1000000, 0.001, 10)
	param = op.AddParameter(pdef)

	op.AlwaysEvaluate = True
	op.Debug = 4
	
	return true

def zJiggleOp_DefineLayout(ctxt):
	lo = ctxt.Source
	
	lo.Clear()
	
	lo.AddItem('RestLength')
	lo.AddItem('Mass')
	lo.AddItem('SpringStiffness')
	lo.AddItem('Gravity')
	lo.AddItem('Damping')
	lo.AddItem('ReactionTime')
	
	lo.AddTab('Debug')
	lo.AddItem('Debug')

def zJiggleOp_Init(ctxt):
	Application.LogMessage("zJiggleOp_Init called", c.siVerbose)
	
	# create some global vectors and a boolean for the init var #
	ctxt.UserData = [ 
		XSIMath.CreateVector3(),
		XSIMath.CreateVector3(), 
		XSIMath.CreateVector3(), 
		XSIMath.CreateVector3(), 
		XSIMath.CreateVector3(), 
		XSIMath.CreateVector3(), 
		XSIMath.CreateVector3(), 
		XSIMath.CreateVector3(), 
		XSIMath.CreateVector3() 
	]
	
	return true

def zJiggleOp_Term(ctxt):
	Application.LogMessage("zJiggleOp_Term called", c.siVerbose)
	return true

def zJiggleOp_Update(ctxt):

	# get the global variables #
	init = ctxt.UserData[0].X
	vCur = ctxt.UserData[1]
	vPrev = ctxt.UserData[2]
	vSpring = ctxt.UserData[3]
	vForceDelta = ctxt.UserData[4]
	vDelta = ctxt.UserData[5]
	vDamp = ctxt.UserData[6]
	vAccel = ctxt.UserData[7]
	
	# get constants #
	restLength = ctxt.Source.RestLength.Value
	mass = ctxt.Source.Mass.Value
	k = ctxt.Source.SpringStiffness.Value
	gravity = ctxt.Source.Gravity.Value
	b = ctxt.Source.Damping.Value
	reaction = ctxt.Source.ReactionTime.Value
	debug = ctxt.Source.Debug
	
	# get the ports #
	springIn = ctxt.GetInputValue('springIn')
	bobIn = ctxt.GetInputValue('bobIn')

	# get the current position #
	springIn.Transform.GetTranslation(vCur)

	# set the initial values #
	# global init
	if debug: log('Init: %s' % init)
	if not init:
		if debug: log('Initializing...')
		# copy the current position #
		vPrev.Copy(vCur)
		# compensate for the spring length #
		vPrev.Y = vPrev.Y - restLength
		init = 1
		ctxt.UserData[0].X = 1
		log('--> %s' % init)
		log('--> %s' % ctxt.UserData[0].X)

	# sanity check, keep things from getting out of hand #
	if vSpring.Length() > 1000 or vForceDelta.Length() > 100:
		if debug: log('SAFETY')
		vPrev.Copy(vCur)
		vPrev.Y = vPrev.Y - restLength
		vSpring.Set(0.0,0.0,0.0)
		vForceDelta.Set(0.1,0.1,0.1)
	
	# calculate the current delta vector #
	vDelta = XSIMath.CreateVector3()
	vDelta.Sub(vCur, vPrev)
	if debug: log('Delta Length: %s' % vDelta.Length())

	# calculate the spring force #
	springForce = k*(vDelta.Length()-restLength)
	if debug: log('Spring Force: %s' % springForce)
	if springForce >=0.0:
		vSpring.Set(
			(vSpring.X*0) + ((vDelta.X/restLength) * springForce),
			(vSpring.Y*0) + ((vDelta.Y/restLength) * springForce),
			(vSpring.Z*0) + ((vDelta.Z/restLength) * springForce) )

	# calculate the damping #
	vDamp.Set(
		vForceDelta.X * b,
		vForceDelta.Y * b,
		vForceDelta.Z * b )

	# calculate the acceleration #
	vAccel.Set(
		(vSpring.X + vDamp.X)/mass,
		((vSpring.Y + vDamp.Y)/mass) - gravity,
		(vSpring.Z + vDamp.Z)/mass )

	# set the new force delta (velocity) #
	vForceDelta.Copy(vAccel)
	# 
	vForceDelta.ScaleInPlace(reaction)

	# add the force delta to the prev position #
	vPrev.AddInPlace(vForceDelta)		

	# set the output #
	if ctxt.OutputPort.Name == 'bobOut':
		trans = bobIn.transform
		trans.SetTranslation(vPrev)
		ctxt.OutputPort.Value.transform = trans
	
	return True
	

def zJiggle_Init(ctxt):
	oCmd = ctxt.Source
	# oCmd.Description = "Attaches a zJiggleOp"
	oCmd.SetFlag(constants.siNoLogging, False)

	oArgs = oCmd.Arguments
	oArgs.Add("jiggleName", c.siArgumentInput, 'zJiggle', c.siString)
	oArgs.AddWithHandler("anchorObject", c.siArgHandlerSingleObj)
	
	return true

def zJiggle_Execute(jiggleName, anchorObject):
	
	# get the anchor object #
	if not anchorObject:
		if xsi.selection.Count:
			anchorObject = xsi.selection(0)
		else:
			picker = xsi.PickElement(None, 'Pick the Anchor Object')
			if not picker[0]:
				log('Cancelled.')
				return False
			else:
				anchorObject = picker[2]
	log('Anchor Object: %s' % anchorObject)
	
	# get the current anchor position #
	tAnchor = anchorObject.Kinematics.Global.Transform
	vAnchor = XSIMath.CreateVector3()
	tAnchor.GetTranslation(vAnchor)
	
	# create a grouping node #
	groupNode = xsi.ActiveSceneRoot.AddNull('%s_Group' % jiggleName)
	groupNode.Kinematics.Global.Transform = tAnchor
	# groupNode.primary_icon.Value = 0
	# groupNode.Properties('Visibility').Parameters('viewvis').Value = False
	# groupNode.Properties('Visibility').Parameters('rendvis').Value = False
	groupNode.shadow_icon.Value = 4
	
	# create three anchor objects #
	anchorCol = dispatch('XSI.Collection')
	anchor1Node = groupNode.AddNull('%s1_Anchor' % jiggleName)
	anchor1Node.primary_icon.Value = 0
	anchor1Node.Properties('Visibility').Parameters('viewvis').Value = False
	anchor1Node.Properties('Visibility').Parameters('rendvis').Value = False
	# anchor1Node.shadow_icon.Value = 4
	anchorCol.Add(anchor1Node)
	trans = XSIMath.CreateTransform()
	trans.Copy(tAnchor)
	trans.AddLocalRotation(
		XSIMath.CreateRotation(0,XSIMath.DegreesToRadians(240),0))
	trans.AddLocalTranslation(XSIMath.CreateVector3(5,0,0))
	anchor1Node.Kinematics.Global.Transform = trans
	
	anchor2Node = groupNode.AddNull('%s2_Anchor' % jiggleName)
	anchor2Node.primary_icon.Value = 0
	anchor2Node.Properties('Visibility').Parameters('viewvis').Value = False
	anchor2Node.Properties('Visibility').Parameters('rendvis').Value = False
	# anchor2Node.shadow_icon.Value = 4
	anchorCol.Add(anchor2Node)
	trans.Copy(tAnchor)
	trans.AddLocalRotation(
		XSIMath.CreateRotation(0,XSIMath.DegreesToRadians(120),0))
	trans.AddLocalTranslation(XSIMath.CreateVector3(5,0,0))
	anchor2Node.Kinematics.Global.Transform = trans
	
	anchor3Node = groupNode.AddNull('%s3_Anchor' % jiggleName)
	anchor3Node.primary_icon.Value = 0
	anchor3Node.Properties('Visibility').Parameters('viewvis').Value = False
	anchor3Node.Properties('Visibility').Parameters('rendvis').Value = False
	# anchor3Node.shadow_icon.Value = 4
	anchorCol.Add(anchor3Node)
	trans.Copy(tAnchor)
	trans.AddLocalTranslation(XSIMath.CreateVector3(5,0,0))
	anchor3Node.Kinematics.Global.Transform = trans
	
	# create a bob object #
	bob = groupNode.AddNull('%s_Bob' % jiggleName)
	bob.primary_icon.Value = 0
	bob.Properties('Visibility').Parameters('viewvis').Value = False
	bob.Properties('Visibility').Parameters('rendvis').Value = False
	v1 = XSIMath.CreateVector3()
	v2 = XSIMath.CreateVector3()
	v3 = XSIMath.CreateVector3()
	anchor1Node.Kinematics.Global.Transform.GetTranslation(v1)
	anchor2Node.Kinematics.Global.Transform.GetTranslation(v2)
	anchor3Node.Kinematics.Global.Transform.GetTranslation(v3)
	vAvg = XSIMath.CreateVector3()
	vAvg.AddInPlace(v1)
	vAvg.AddInPlace(v2)
	vAvg.AddInPlace(v3)
	vAvg.ScaleInPlace(1.0/3.0)
	trans = bob.Kinematics.Global.Transform
	trans.SetTranslation(vAvg)
	rot = XSIMath.CreateRotation()
	groupNode.Kinematics.Global.Transform.GetRotation(rot)
	trans.SetRotation(rot)
	bob.Kinematics.Global.Transform = trans
	
	# turn anchors into passive rigid bodies #
	xsi.CreatePassiveRigidBody(anchorCol)
	
	# turn anchors into passive active bodies #
	xsi.CreateActiveRigidBody(bob)
	
	# create the spring #
	vBob = XSIMath.CreateVector3()
	springCol = dispatch('XSI.Collection')
	bob.Kinematics.Global.Transform.GetTranslation(vBob)
	spring1 = xsi.AttachRigidBodies('Spring', '%s,%s' % (bob, anchor1Node),
				vBob.X, vBob.Y, vBob.Z)
	springCol.Add(spring1)
	spring2 = xsi.AttachRigidBodies('Spring', '%s,%s' % (bob, anchor2Node),
				vBob.X, vBob.Y, vBob.Z)
	springCol.Add(spring2)
	spring3 = xsi.AttachRigidBodies('Spring', '%s,%s' % (bob, anchor3Node),
				vBob.X, vBob.Y, vBob.Z)
	springCol.Add(spring3)
	groupNode.AddChild(springCol)
	
		
	# pose constrain the anchors to the group node #
	for anchor in anchorCol:
		anchor.Kinematics.AddConstraint('Pose', groupNode, True)
		
	# create a ppg control #
	prop = groupNode.AddCustomProperty('zJiggle', False)
	prop = dispatch(prop)
	paramSpring = prop.AddParameter2('Spring', c.siDouble, 60, 0, 1000000, 0, 200, c.siClassifUnknown, c.siPersistable+c.siAnimatable, 'Spring (Kp)')
	paramDamping = prop.AddParameter2('Damping', c.siDouble, 12, 0, 1000000, 0, 100, c.siClassifUnknown, c.siPersistable+c.siAnimatable, 'Damping (Kd)')
	paramLength = prop.AddParameter2('RestLength', c.siDouble, 1,  0, 1000000, 0, 10, c.siClassifUnknown, c.siPersistable+c.siAnimatable, 'Rest Length (R)')
	paramMass = prop.AddParameter2('Mass', c.siDouble, 2,  0, 1000000, 0.001, 10, c.siClassifUnknown, c.siPersistable+c.siAnimatable, 'Mass')
	
	# hook up spring parameters to custom ppg #
	for spring in springCol:
		spring.Spring_Constant.AddExpression(paramSpring.FullName)
		spring.Damping_Constant.AddExpression(paramDamping.FullName)
		spring.Rest_Length.AddExpression(paramLength.FullName)
		
		# hide it #
		dispatch(spring.Properties('Visibility')).viewvis.Value = False
	
	# hook up the mass #
	dispatch(bob.Properties('Inertial Properties')).mass.AddExpression(paramMass.FullName)
	# dispatch(bob.InertialProps).mass.AddExpression(paramMass.FullName)
		
	# constrain the bob orientation to the group node #
	hook = groupNode.AddNull('%s_Hook' % jiggleName)
	hook.primary_icon.Value = 2
	hook.Kinematics.AddConstraint('Position', bob, False)
	hook.Kinematics.AddConstraint('Orientation', groupNode, False)
	
	# show the ppg #
	xsi.InspectObj(prop)
