# RigTools
# Initial code generated by XSI SDK Wizard
# Executed Sat Jun 24 11:33:24 PDT 2006 by andy
# 
# Tip: To add a command to this plug-in, right-click in the 
# script editor and choose Tools > Add Command.
# 
# Tip: To get help on a callback, highlight the callback name
# (for example, "Init", "Define", or "Execute") and press F1.
import win32com
import win32com.client
from win32com.client import constants
from win32com.client import constants as c

xsi = Application

null = None
false = 0
true = 1



def XSILoadPlugin( in_reg ):
	in_reg.Author = "andy"
	in_reg.Name = "RigTools"
	in_reg.Email = ""
	in_reg.URL = ""
	in_reg.Major = 1
	in_reg.Minor = 0

	# custom props #
	in_reg.RegisterProperty( "RigLandmark" ) 
	in_reg.RegisterProperty( "RigSpineCurve" ) 
	in_reg.RegisterProperty( "RigLandmarkModel" ) 
	
	# menus #
	# in_reg.RegisterMenu( c.siMenuMainTopLevelID, "Rigging Tools" )

	in_reg.RegisterCommand("landmarks","landmarks")
	in_reg.RegisterCommand("createLandmark","createLandmark")
	in_reg.RegisterCommand("curveToSpine","curveToSpine")
	
	in_reg.RegisterCommand("buildBiped","buildBiped")
	in_reg.RegisterCommand("ZooBuildSpineFromSpineCurve", "Build Spine From Spine Curve")
	#RegistrationInsertionPoint - do not remove this line

	return true

def XSIUnloadPlugin( in_reg ):
	strPluginName = in_reg.Name
	Application.LogMessage(str(strPluginName) + str(" has been unloaded."))
	return true

def RiggingTools_Init( ctxt ):
	menu = ctxt.Source
	menu.Name = "&Ass Face"; # useless on top level menus
	
	menu.AddCommandItem( "Create Landmark", "createLandmark" );
	menu.AddCommandItem( "Create Spine From Curve", "curveToSpine" );


def RigLandmarkModel_Define( ctxt ):
	
	# only updated when the software is loaded or the first
	# time it's created.  To update, create a property and
	# use XSIUtils.Reload( prop )
	#	xsi = Application
	#	xsi.UpdatePlugins()
	#	n = xsi.ActiveSceneRoot.AddNull()
	#	p = n.AddProperty( 'RigLandmark' )
	#	xsi.InspectObj( p )
	
	# !! found issues with layouts using parameters called 'Name'
	
	# to update the property and see layout changes, use the above example code
	# inspect the object and trl+shift+rmb on the title bar and 
	# select refresh
	
	prop = ctxt.Source
	man  = prop.AddParameter3( 'Manifest', c.siString, '' )
	man.ReadOnly = True
	dte  = prop.AddParameter3( 'Date', c.siString, '' )
	dte.ReadOnly = True

def RigLandmarkModel_DefineLayout( ctxt ):
	
	# to see updates, open the ppg ctrl+shift+rmb on the 
	# title bar and select refresh
	
	ppg = ctxt.Source
	
	ppg.Clear()
	ppg.AddButton( 'buildManifest', 'Build Manifest' )
	
	ppg.AddGroup('Timestamp')
	ppg.AddString( 'Date', 'Date', False )
	ppg.EndGroup()
	
	ppg.AddGroup()
	ppg.AddString( 'Manifest', 'Manifest Destiny', True, 50 )
	ppg.EndGroup()

def RigLandmarkModel_buildManifest_OnClicked():
	ppg = PPG.Inspected(0)
	xsi.logmessage( ppg.Model.Name )
	buildManifest( ppg.Model, ppg )

def buildManifest( model, ppg ):
	
	# create a mapping dictionary of names to objects #
	dict_lm = {}
	
	# step through all objects on the model #
	for obj in model.FindChildren( '*' ):
		if obj.Properties( 'RigLandmark' ):
			xsi.logmessage( 'Found Landmark: %s' % obj )
			prop = win32com.client.Dispatch( obj.Properties( 'RigLandmark' ) )
			name = prop.Parameters( 'LandmarkName' ).Value
			sfx = prop.Parameters( 'Sfx' ).Value
			
			# get jsut the plain name #
			plain_name = name
			if sfx:
				plain_name = name[:-4]

			# split it on the underscores #
			splt = plain_name.split('_')
			base_name = splt[0]
			xsi.logmessage( base_name )
			
			# find the symmetry #
			sym = 'None'
			if len(splt) > 1:
				sym = splt[1]
			
			# add the obj to the dict #
			if not dict_lm.has_key( base_name ):
				dict_lm[ base_name ] = { sym: obj.Name }
			else:
				dict_lm[ base_name ][ sym ] = obj.Name
			
		if obj.Properties( 'RigSpineCurve' ):
			xsi.logmessage( 'Found Spine Curve: %s' % obj )
			dict_lm[ 'SpineCurve' ] = obj.Name
			
	xsi.logmessage( `dict_lm` )
	# pickle the dict and store it in the string field #
	import cPickle
	pkl = cPickle.dumps( dict_lm )
	ppg.Parameters( 'Manifest' ).Value  = pkl
#	xsi.logmessage( pkl )
#	xsi.logmessage( `cPickle.loads( str( ppg.Parameters( 'Manifest' ).Value ) )`)

	# set the manifest timestamp #
	import time
	ppg.Parameters( 'Date' ).Value  = time.asctime( time.localtime() )

def RigLandmark_Define( ctxt ):
	
	# only updated when the software is loaded or the first
	# time it's created.  To update, create a property and
	# use XSIUtils.Reload( prop )
	#	xsi = Application
	#	xsi.UpdatePlugins()
	#	n = xsi.ActiveSceneRoot.AddNull()
	#	p = n.AddProperty( 'RigLandmark' )
	#	xsi.InspectObj( p )
	
	# !! found issues with layouts using parameters called 'Name'
	
	# to update the property and see layout changes, use the above example code
	# inspect the object and trl+shift+rmb on the title bar and 
	# select refresh
	
	prop = ctxt.Source
	typ  = prop.AddParameter3( 'Typical', c.siString, '' )
	typ  = prop.AddParameter3( 'CustomName', c.siString, '' )
	name = prop.AddParameter3( 'LandmarkName', c.siString, typ.Value, None, None, False, True )
	sym  = prop.AddParameter3( 'Symmetry', c.siString, '' )
	num  = prop.AddParameter3( 'Num', c.siUInt2, 0, 0, 10, False )
	sfx  = prop.AddParameter3( 'Sfx', c.siBool, 1, 0, 1, False )
#	siz  = win32com.client.dynamic.Dispatch( prop.AddParameter3( 'Size', c.siFloat, 1  ) )
	siz  = prop.AddParameter2( 'Size', c.siFloat, 1, 0, None, 0, 2  )
	siz.Animatable = False

	
	return true

def RigLandmark_DefineLayout( ctxt ):
	
	# to see updates, open the ppg ctrl+shift+rmb on the 
	# title bar and select refresh
	
	plo = ctxt.Source
	
	plo.Clear()
	
	plo.AddGroup( 'Typical' )
	plo.AddRow()
	item_legs = plo.AddEnumControl( 'Typical', 
						 [ 'Thigh', 'thigh',
						   'Shin', 'shin', 
						   'Ankle', 'ankle', 
						   'Foot', 'foot', 
						   'Toe', 'toe' ],
						  'Legs',  
						  c.siControlRadio )
#	item_legs.WidthPercentage = 50
	item_arms = plo.AddEnumControl( 'Typical', 
						 [ "Upperarm", "upperarm",
						   "Forearm", "forearm", 
						   'Hand', 'hand',
						   'Finger', 'finger' ],
						  'Arms',  
						  c.siControlRadio )
#	item_arms.WidthPercentage = 50
	plo.EndRow()
	plo.AddSpacer()
	plo.AddRow()
	item_torso = plo.AddEnumControl( 'Typical', 
						 [ 'Body', 'body',
						   'Spine', 'spine', 
						   'Chest', 'chest', 
						   'Neck', 'neck', 
						   'Head', 'head' ],
						  'Torso',  
						  c.siControlRadio )
	item_torso = plo.AddEnumControl( 'Typical', 
						 [ 'Center', 'center',
						   'Floor', 'floor'],
						  'Misc',  
						  c.siControlRadio )
	plo.EndRow()
	plo.EndGroup()
	
	plo.AddGroup( 'Symmetry' )
	plo.AddEnumControl( 'Symmetry', 
						 [ 'None', '',
						   'Left', 'Lft', 
						   'Right', 'Rgt',
						   'Front', 'Fnt',
						   'Back', 'Bck',
						   'Top', 'Top',
						   'Middle', 'Mid',
						   'Bottom', 'Btm' ],
						  "Symmetry",  
						  c.siControlCombo )
	plo.EndGroup()
	
	plo.AddGroup( 'Custom' )
	plo.AddRow()
	plo.AddItem( 'CustomName', 'Custom Name' )
	plo.AddButton( 'ClrCustomName', 'Clr' )
	plo.EndRow()
#	plo.EndGroup()
#	
#	plo.AddGroup()
	plo.AddRow()
	num_item = plo.AddItem( 'Num', 'Number' )
#	num_item.SetAttribute( c.siUIThumbWheel, True )
	num_item.WidthPercentage = 75
	item_sfx = plo.AddItem( 'Sfx', 'Use Suffix' )
	item_sfx.WidthPercentage = 35
	plo.EndRow()
	plo.AddRow()
	plo.EndRow()
	plo.EndGroup()
	
	plo.AddGroup('Landmark Name')
	plo.AddRow()
	item_name = plo.AddItem( 'LandmarkName', 'Name' )
	item_name.WidthPercentage = 60
	item_ren = plo.AddButton( 'RenameObj', 'Rename Object' )
	item_ren.WidthPercentage = 15
#	item_sfx.siUILabelMinPixels = 20
	plo.EndRow()
	item_siz = plo.AddItem( 'Size' )
	plo.EndGroup()
 
	plo.AddRow()
	plo.AddButton( 'NewLandmark', 'New Landmark' )
	plo.EndRow()
	
	return true
	
def RigLandmark_OnInit():
	xsi.logmessage( 'Init Rig Landmark PPG' )
	return true

def setLandmarkNameFromPPG():
	
	# get the current ppg #
	plo = PPG.Inspected(0)
	
	setLandmarkName( plo )
def setLandmarkName( prop ):
	
	# get the parameters #
	sfx = prop.Parameters( 'Sfx' )
	typ = prop.Parameters( 'Typical' )
	cus = prop.Parameters( 'CustomName' )
	sym = prop.Parameters( 'Symmetry' )
	num = prop.Parameters( 'Num' )

	# build the landmark name #
	new_name = typ.Value
	if cus.Value:
		new_name = cus.Value
		typ.ReadOnly = True
	else:
		typ.ReadOnly = False
	if num.Value:
		new_name = '%s%s' % ( new_name, num.Value )
	if sym.Value:
		new_name = '%s_%s' % ( new_name, sym.Value )
		
	if sfx.Value:
		new_name = new_name + '_LMK'

	# set the landmark name #
	prop.Parameters( 'LandmarkName' ).Value = new_name
	
	renameObject( prop )
	
def RigLandmark_Typical_OnChanged():
	setLandmarkNameFromPPG()
	
def RigLandmark_CustomName_OnChanged():
	setLandmarkNameFromPPG()
	
def RigLandmark_Symmetry_OnChanged():
	setLandmarkNameFromPPG()
	
def RigLandmark_Num_OnChanged():
	setLandmarkNameFromPPG()
	
def RigLandmark_Sfx_OnChanged():
	setLandmarkNameFromPPG()
	
def RigLandmark_Size_OnChanged():
	plo = PPG.Inspected(0)
	obj = plo.Parent
	obj.Size = plo.Parameters( 'Size' ).Value
	
def RigLandmark_NewLandmark_OnClicked():
	
	plo = PPG.Inspected(0)
	
	lmk = xsi.createLandmark( 'landmark', 
							plo.Parameters( 'Symmetry' ).Value, 
							plo.Parameters( 'Size' ).Value )
	
	# align the objects #
	lmk.Kinematics.Global.Transform = plo.Parent.Kinematics.Global.Transform
	
	return true
	
def RigLandmark_ClrCustomName_OnClicked():
	''' Clears the custom name '''
	
	plo = PPG.Inspected(0)
	
	# clear the parameter #
	plo.Parameters( 'CustomName' ).Value = ''
	
	# reset the name #
	setLandmarkNameFromPPG()	
			
def RigLandmark_RenameObj_OnClicked():
	''' renames the parent object '''
	plo = PPG.Inspected(0)
	renameObject( plo )

def renameObject( prop ):	
	xsi.logmessage( 'Prnt: %s' % prop.Parent )
	obj = prop.Parent
	obj.Name = prop.Parameters( 'LandmarkName' ).Value
	
	
def createLandmark_Init( ctxt ):
	oCmd = ctxt.Source
	oCmd.Description = ""
	oCmd.ReturnValue = true

	oArgs = oCmd.Arguments
	oArgs.Add( "lname", constants.siArgumentInput, 'landmark', c.siString )
	oArgs.Add( "sym", constants.siArgumentInput, '', c.siString )
	oArgs.Add( "size", constants.siArgumentInput, float(1), c.siFloat )
	oArgs.Add( "select", constants.siArgumentInput, True, c.siBool )
	
	return true

def createLandmark_Execute( lname, sym, size, select ):

	# see if a landmarks model exists, if not, make one #
	mdl_marks = None
	for model in xsi.ActiveSceneRoot.Models:
		if model.Properties( 'RigLandmarkModel' ): 
			mdl_marks = model
			break
	
	if not mdl_marks:
		mdl_marks = xsi.ActiveSceneRoot.AddModel( None, 'Landmarks' )
		mdl_marks.AddProperty( 'RigLandmarkModel', False )
	
	# create the null #	
	mrk = mdl_marks.AddNull( lname )
	
	# change the display #
	mrk.Parameters( 'shadow_icon' ).Value = 10
	mrk.Parameters( 'shadow_colour_custom' ).Value = 1
	mrk.Parameters( 'R' ).Value = .5
	
	disp = mrk.AddProperty( 'Display Property' )
	disp.Parameters( 'wirecol' ).Value = 562
	
	# add a landmark property #
	prop = mrk.AddProperty( 'RigLandmark' )
	prop.Parameters( 'CustomName' ).Value = mrk.Name
	prop.Parameters( 'Symmetry' ).Value = sym
	prop.Parameters( 'Size' ).Value = size
	mrk.Size = size
	
	if select:
		xsi.InspectObj( prop, '', '', c.siFollow )
	
	# build the name from 
	setLandmarkName( prop )
	
	# rename the object #
	renameObject( prop )
	
	if select:
		xsi.DeselectAll()
		mrk.Selected = True

	return mrk

def RigSpineCurve_Define( ctxt ):
	
	prop = ctxt.Source
	typ  = prop.AddParameter3( 'lumbar', c.siUInt2, 5, 1, 5, False )
	typ  = prop.AddParameter3( 'thoratic', c.siUInt2, 12, 1, 12, False )
	typ  = prop.AddParameter3( 'cervical', c.siUInt2, 7, 1, 7, False )
	typ  = prop.AddParameter3( 'landmarks', c.siString, '', None, None, False, True )
#	name = prop.AddParameter3( 'LandmarkName', c.siString, typ.Value, None, None, False, True )
#	sym  = prop.AddParameter3( 'Symmetry', c.siString, '' )
#	num  = prop.AddParameter3( 'Num', c.siUInt2, 0, 0, 6, False )
#	sfx  = prop.AddParameter3( 'Sfx', c.siBool, 1, 0, 1, False )
##	siz  = win32com.client.dynamic.Dispatch( prop.AddParameter3( 'Size', c.siFloat, 1  ) )
#	siz  = prop.AddParameter2( 'Size', c.siFloat, 1, 0, None, 0, 2  )
#	siz.Animatable = False

	
	return true

def RigSpineCurve_DefineLayout( ctxt ):
	
	# to see updates, open the ppg ctrl+shift+rmb on the 
	# title bar and select refresh
	
	plo = ctxt.Source
	
def curveToSpine_Init( ctxt ):
	oCmd = ctxt.Source
	oCmd.Description = ""
	oCmd.ReturnValue = true

#	oArgs = oCmd.Arguments
#	oArgs.Add( "lname", constants.siArgumentInput, 'landmark', c.siString )
#	oArgs.Add( "sym", constants.siArgumentInput, '', c.siString )
#	oArgs.Add( "size", constants.siArgumentInput, float(1), c.siFloat )
	
	return true

def curveToSpine_Execute():
	
	# step through selection and be sure we have a curve selected #
	crv = None
	if not xsi.selection.Count:
		xsi.logmessage( 'Nothing Selected.', c.siError )
		return None
	
	for sel in xsi.selection:
		if sel.Type == 'crvlist':
			crv = sel
			break
		
	if not crv:
		xsi.logmessage( 'No curve found in selection.', c.siError )
		return None
	
	# tag the curve #
	prop_spine = crv.AddProperty( 'RigSpineCurve', False )
	
	# see if a landmarks model exists, if not, make one #
	mdl_marks = None
	for model in xsi.ActiveSceneRoot.Models:
		if model.Properties( 'Rig_Landmarks' ): 
			mdl_marks = model
			break
	
	if not mdl_marks:
		mdl_marks = xsi.ActiveSceneRoot.AddModel( None, 'Landmarks' )
		mdl_marks.AddProperty( 'CustomProperty', False, 'Rig_Landmarks' )

	# move it to the landmark model #
	mdl_marks.AddChild( crv )
	
	# create a collection of landmarks #
	col_lm = win32com.client.Dispatch( 'XSI.Collection' )
	
	# create cluster handles for the top and bottom #
	points = crv.ActivePrimitive.Geometry.Points
	pa = points.PositionArray
	
	cls_base = crv.ActivePrimitive.Geometry.AddCluster( c.siVertexCluster, None, [0] )
	cls_head = crv.ActivePrimitive.Geometry.AddCluster( c.siVertexCluster, None, [points.Count-1] )
	
	lm_spine = xsi.createLandmark( 'spineBase', None, None, False )
	lm_head  = xsi.createLandmark( 'headBase', None, None, False )
	crv.AddChild( lm_spine )
	crv.AddChild( lm_head )
	
	tfm_spine = lm_spine.Kinematics.Local.Transform
	v_spine = XSIMath.CreateVector3( pa[0][0], pa[1][0], pa[2][0])
	tfm_spine.SetTranslation( v_spine )
	lm_spine.Kinematics.Local.Transform = tfm_spine
	
	tfm_head = lm_head.Kinematics.Local.Transform
	v_head = XSIMath.CreateVector3( pa[0][-1], pa[1][-1], pa[2][-1])
	tfm_head.SetTranslation( v_head )
	lm_head.Kinematics.Local.Transform = tfm_head
	
	cls_base.CenterReference = lm_spine
	cls_head.CenterReference = lm_head

	# create landmarks #
	lm_chest = xsi.createLandmark( 'chestBase', None, None, False )
	lm_neck  = xsi.createLandmark( 'neckBase', None, None, False )
	crv.AddChild( lm_chest )
	crv.AddChild( lm_neck )
	pth_chest = lm_chest.Kinematics.AddConstraint( 'Path', crv )
	pth_chest = win32com.client.dynamic.Dispatch( pth_chest )
	pth_chest.Parameters( 'perc' ).Value = 30
	pth_chest.Parameters( 'tangent' ).Value = 1
	pth_chest.Parameters( 'upvct_active' ).Value = 1
	
	pth_neck  = lm_neck.Kinematics.AddConstraint( 'Path', crv )
	pth_neck = win32com.client.dynamic.Dispatch( pth_neck )
	pth_neck.Parameters( 'perc' ).Value = 80
	pth_neck.Parameters( 'tangent' ).Value = 1
	pth_neck.Parameters( 'upvct_active' ).Value = 1
	
	# set the landmarks variable #
	lms = [ lm_spine.Name, lm_chest.Name, lm_neck.Name, lm_head.Name ]
	xsi.logmessage( ','.join( lms ) )
	prop_spine.Parameters( 'landmarks' ).Value = ','.join( lms )
	
	
def ZooBuildSpineFromSpineCurve_Init( ctxt ):
	oCmd = ctxt.Source
	oCmd.Description = ""
	oCmd.ReturnValue = true

#	oArgs = oCmd.Arguments
#	oArgs.Add( "lname", constants.siArgumentInput, 'landmark', c.siString )
#	oArgs.Add( "sym", constants.siArgumentInput, '', c.siString )
#	oArgs.Add( "size", constants.siArgumentInput, float(1), c.siFloat )
	
	return true

def ZooBuildSpineFromSpineCurve_Execute():
	
	# make sure we have a selected curve #
	if not xsi.selection.Count or \
	xsi.selection(0).Type != 'crvlist' or \
	not xsi.selection(0).Properties( 'RigSpineCurve' ):
		xsi.logmessage( 'No Spine curve selected.', c.siError )
		return False
	
	# get the model name from the curve #
	model_lm = xsi.selection(0).Model

	########################################
	# build spine
	#
	col = win32com.client.Dispatch( 'XSI.Collection' )
	col.SetAsText( '%s.spineBase_LMK' % model_lm.Fullname )
	lm_spine = col(0)
	col.SetAsText( '%s.chestBase_LMK' % model_lm.Fullname )
	lm_chest = col(0)
	col.SetAsText( '%s.neckBase_LMK' % model_lm.Fullname )
	lm_neck = col(0)
	col.SetAsText( '%s.headBase_LMK' % model_lm.Fullname )
	lm_head = col(0)

	# duplicate the spine curve #
	crv_spine = xsi.Duplicate( lm_neck.parent )(0)
	xsi.ActiveSceneRoot.AddChild( crv_spine )

	# get the vectors #
	v_spine  = XSIMath.CreateVector3()
	lm_spine.Kinematics.Global.Transform.GetTranslation( v_spine )
	v_chest  = XSIMath.CreateVector3()
	lm_chest.Kinematics.Global.Transform.GetTranslation( v_chest )
	v_neck  = XSIMath.CreateVector3()
	lm_neck.Kinematics.Global.Transform.GetTranslation( v_neck )
	v_head  = XSIMath.CreateVector3()
	lm_head.Kinematics.Global.Transform.GetTranslation( v_head )
	
	# find the constraints #
	cns_chest = dispFix( lm_chest.Kinematics.Constraints(0) )
	perc_chest = cns_chest.Parameters( 'perc' ).Value
		
	cns_neck = dispFix( lm_neck.Kinematics.Constraints(0) )
	perc_neck = cns_neck.Parameters( 'perc' ).Value
	
	prop_spine = dispFix( crv_spine.Properties( 'RigSpineCurve' ) )
	num_lum = prop_spine.Parameters( 'lumbar' ).Value
	num_thr = prop_spine.Parameters( 'thoratic' ).Value
	num_crv = prop_spine.Parameters( 'cervical' ).Value
	
	inc_lum = perc_chest/num_lum
	inc_thr = (perc_neck-perc_chest)/num_thr
	inc_crv = (100-perc_neck)/num_crv
	
	# calculate the normal plain #
	v_plain = XSIMath.CreateVector3()
	v_sub1 = XSIMath.CreateVector3()
	v_sub2 = XSIMath.CreateVector3()
	v_sub1.Sub( v_chest, v_head )
	v_sub2.Sub( v_chest, v_neck )
	v_plain.Cross( v_sub1, v_sub2 )
		
	root_lum = None
	for i in xrange(num_lum):
#		xsi.logmessage( '%s %s %s %s' % ( i, perc_chest, inc_lum, inc_lum*(i+1) ) )
		
		# get the point on curve #
		crv = crv_spine.ActivePrimitive.Geometry.Curves(0)
		v_pos_end = crv.EvaluatePositionFromPercentage( 100 )[0]
		v_pos_start = crv.EvaluatePositionFromPercentage( 0 )[0]
		v_pos_cur = crv.EvaluatePositionFromPercentage( inc_lum*(i) )[0]
		v_pos_nxt = crv.EvaluatePositionFromPercentage( inc_lum*(i+1) )[0]

		if not root_lum:
		
			# build the chain #
			root_lum = xsi.ActiveSceneRoot.Add2DChain( v_pos_cur, v_pos_nxt, v_plain, c.si2DChainNormalRadian, 
											'lumbar%s_Mid_Chn'%(i+1) )
			root_lum = dispFix( root_lum )
			root_lum.effector.Name = 'lumbar%s_Mid_Eff'%(i+1)
			root_lum.Bones(0).Name = 'lumbar%s_Mid_Bone'%(i+1)
			
			cns = dispFix( root_lum.Kinematics.AddConstraint( 'Path', crv_spine, False ) )
			cns.Parameters( 'perc' ).Value = inc_lum*(i)
			
		else:
			bone = root_lum.AddBone( v_pos_nxt, c.siChainBonePin, 'lumbar%s_Mid_Bone'%(i+1) )
			cns = dispFix( bone.Kinematics.AddConstraint( 'Path', crv_spine, False ) )
			cns.Parameters( 'perc' ).Value = inc_lum*(i)
			
	cns = dispFix( root_lum.effector.Kinematics.AddConstraint( 'Path', crv_spine, False ) )
	cns.Parameters( 'perc' ).Value = perc_chest
#	formatChain( root_lum, 0.75 )
		
	root_thr = None
	for i in xrange(num_thr):
		
		# get the point on curve #
		crv = crv_spine.ActivePrimitive.Geometry.Curves(0)
		v_pos_cur = crv.EvaluatePositionFromPercentage( perc_chest+(inc_thr*(i)) )[0]
		v_pos_nxt = crv.EvaluatePositionFromPercentage( perc_chest+(inc_thr*(i+1)) )[0]
		v_pos_end = crv.EvaluatePositionFromPercentage( 100 )[0]
		v_pos_start = crv.EvaluatePositionFromPercentage( 0 )[0]
		
		if not root_thr:
		
			# build the chain #
			root_thr = xsi.ActiveSceneRoot.Add2DChain( v_pos_cur, v_pos_nxt, v_plain, c.si2DChainNormalRadian, 
											'thorax%s_Mid_Chn'%(i+1) )
			root_thr = dispFix( root_thr )
			root_thr.effector.Name = 'thorax%s_Mid_Eff'%(i+1)
			root_thr.Bones(0).Name = 'thorax%s_Mid_Bone'%(i+1)
			
			
		else:
			bone = root_thr.AddBone( v_pos_nxt, c.siChainBonePin, 'thorax%s_Mid_Bone'%(i+1) )
	

	for i in xrange(num_thr):
		if i==0:
			cns = dispFix( root_thr.Kinematics.AddConstraint( 'Position', root_lum.effector, False ) )
#			cns = dispFix( root_thr.Kinematics.AddConstraint( 'Path', crv_spine, False ) )
#			cns.Parameters( 'perc' ).Value = perc_chest+(inc_thr*(i))
		else:
			cns = dispFix( root_thr.bones(i).Kinematics.AddConstraint( 'Path', crv_spine, False ) )
			cns.Parameters( 'perc' ).Value = perc_chest + (inc_thr*(i))
			
	cns = dispFix( root_thr.effector.Kinematics.AddConstraint( 'Path', crv_spine, False ) )
	cns.Parameters( 'perc' ).Value = perc_neck

#	formatChain( root_thr, 0.75 )

	root_crv = None
	for i in xrange(num_crv):
#		xsi.logmessage( '%s %s %s %s' % ( i, perc_chest, inc_lum, inc_lum*(i+1) ) )
		
		# get the point on curve #
		crv = crv_spine.ActivePrimitive.Geometry.Curves(0)
		v_pos_cur = crv.EvaluatePositionFromPercentage( perc_neck+(inc_crv*(i)) )[0]
		v_pos_nxt = crv.EvaluatePositionFromPercentage( perc_neck+(inc_crv*(i+1)) )[0]
		v_pos_end = crv.EvaluatePositionFromPercentage( 100 )[0]
		v_pos_start = crv.EvaluatePositionFromPercentage( 0 )[0]
		
		if not root_crv:
		
			# build the chain #
			root_crv = xsi.ActiveSceneRoot.Add2DChain( v_pos_cur, v_pos_nxt, v_plain, c.si2DChainNormalRadian, 
											'cervical%s_Mid_Chn'%(i+1) )
			root_crv = dispFix( root_crv )
			root_crv.effector.Name = 'cervical%s_Mid_Eff'%(i+1)
			root_crv.Bones(0).Name = 'cervical%s_Mid_Bone'%(i+1)
			
		else:
			bone = root_crv.AddBone( v_pos_nxt, c.siChainBonePin, 'cervical%s_Mid_Bone'%(i+1) )
			
	for i in xrange(num_crv):
		if i==0:
			cns = dispFix( root_crv.Kinematics.AddConstraint( 'Position', root_thr.effector, False ) )
#			cns = dispFix( root_crv.Kinematics.AddConstraint( 'Path', crv_spine, False ) )
#			cns.Parameters( 'perc' ).Value = perc_neck + (inc_crv*(i))
		else:
			cns = dispFix( root_crv.bones(i).Kinematics.AddConstraint( 'Path', crv_spine, False ) )
			cns.Parameters( 'perc' ).Value = perc_neck + (inc_crv*(i))
			
	cns = dispFix( root_crv.effector.Kinematics.AddConstraint( 'Path', crv_spine, False ) )
	cns.Parameters( 'perc' ).Value = 100

#	formatChain( root_crv, 0.75 )
		


def buildBiped_Init( ctxt ):
	oCmd = ctxt.Source
	oCmd.Description = ""
	oCmd.ReturnValue = true

#	oArgs = oCmd.Arguments
#	oArgs.Add( "lname", constants.siArgumentInput, 'landmark', c.siString )
#	oArgs.Add( "sym", constants.siArgumentInput, '', c.siString )
#	oArgs.Add( "size", constants.siArgumentInput, float(1), c.siFloat )
	
	return true

def landmarks_Init( ctxt ):
	oCmd = ctxt.Source
	oCmd.Description = ""
	oCmd.ReturnValue = true

	return true

def buildBiped_Execute():
	
	# find the landmarks model #
	model_lm = None
	for model in xsi.ActiveSceneRoot.Models:
		if model.Properties( 'RigLandmarkModel' ):
			model_lm = model
			break
		
	if not model_lm:
		xsi.logmessage( 'Unable to find Landmark Model', c.siError )
		return False
	
	# read in the manifest #
	dict_lm = None

	try:
		prop = win32com.client.Dispatch( model_lm.Properties( 'RigLandmarkModel' ) )
		pkl_str = prop.Parameters( 'Manifest' ).Value
		import cPickle
		dict_lm = cPickle.loads( str( pkl_str ) )
	except:
		xsi.logmessage( 'Unable to get Landmark Manifest', c.siError )
		return False
	
	# get the rig model #
	# see if a landmarks model exists, if not, make one #
	mdl_rig = None
	for model in xsi.ActiveSceneRoot.Models:
		if model.Properties( 'RigSkeleton' ): 
			mdl_rig = model
			break
	
	if not mdl_rig:
		mdl_rig = xsi.ActiveSceneRoot.AddModel( None, 'Skeleton' )
		mdl_rig.AddProperty( 'CustomProperty', False, 'RigSkeleton' )
	
	
	########################################
	# build left leg 
	#
	col = win32com.client.Dispatch( 'XSI.Collection' )
	col.SetAsText( '%s.%s' % ( model_lm.Fullname,
							   dict_lm['hip']['Lft']) )
	lm_hip = col(0)
	
	col.SetAsText( '%s.%s' % ( model_lm.Fullname,
							   dict_lm['knee']['Lft']) )
	lm_knee = col(0)
	
	col.SetAsText( '%s.%s' % ( model_lm.Fullname,
							   dict_lm['ankle']['Lft']) )
	lm_ankle = col(0)
	
	v_hip = XSIMath.CreateVector3()
	v_knee = XSIMath.CreateVector3()
	v_ankle = XSIMath.CreateVector3()
	lm_hip.Kinematics.Global.Transform.GetTranslation( v_hip )
	lm_knee.Kinematics.Global.Transform.GetTranslation( v_knee )
	lm_ankle.Kinematics.Global.Transform.GetTranslation( v_ankle )
	
	# calculate the normal plain #
	v_plain = XSIMath.CreateVector3()
	v_sub1 = XSIMath.CreateVector3()
	v_sub2 = XSIMath.CreateVector3()
	v_sub1.Sub(v_hip, v_knee)
	v_sub2.Sub(v_hip, v_ankle)
	v_plain.Cross( v_sub1, v_sub2 )
	
	root_lleg = mdl_rig.Add2DChain( v_hip, v_knee, v_plain, c.si2DChainNormalRadian, 'leg_Lft_Chn' )
	root_lleg = dispFix( root_lleg )
	root_lleg.effector.Name = 'thigh_Lft_Eff'
	root_lleg.Bones(0).Name = 'thigh_Lft_Bone'
	root_lleg.AddBone( v_ankle, c.siChainBonePin, 'shin_Lft_Bone' )
	
	
	########################################
	# build right leg 
	#
	
	# mirror the vectors and create the right leg #
	v_hip.X = v_hip.X * -1
	v_knee.X = v_knee.X * -1
	v_ankle.X = v_ankle.X * -1
	v_sub1.Sub(v_hip, v_knee)
	v_sub2.Sub(v_hip, v_ankle)
	v_plain.Cross( v_sub1, v_sub2 )
	
	root_rleg = mdl_rig.Add2DChain( v_hip, v_knee, v_plain, c.si2DChainNormalRadian, 'leg_Rgt_Chn' )
	root_rleg = dispFix( root_rleg )
	root_rleg.effector.Name = 'thigh_Rgt_Eff'
	root_rleg.Bones(0).Name = 'thigh_Rgt_Bone'
	root_rleg.AddBone( v_ankle, c.siChainBonePin, 'shin_Rgt_Bone' )
	
	# format the legs #
	formatChain( root_lleg )
	formatChain( root_rleg )

	########################################
	# build left foot 
	#
	col = win32com.client.Dispatch( 'XSI.Collection' )
	col.SetAsText( '%s.%s' % ( model_lm.Fullname,
							   dict_lm['football']['Lft']) )
	lm_fball = col(0)
	
	col.SetAsText( '%s.%s' % ( model_lm.Fullname,
							   dict_lm['footend']['Lft']) )
	lm_fend = col(0)
	

	v_ankle.X = v_ankle.X * -1

	v_fball = XSIMath.CreateVector3()
	v_fend = XSIMath.CreateVector3()
	lm_fball.Kinematics.Global.Transform.GetTranslation( v_fball )
	lm_fend.Kinematics.Global.Transform.GetTranslation( v_fend )
	
	# calculate the normal plain #
	v_plain = XSIMath.CreateVector3()
	v_sub1 = XSIMath.CreateVector3()
	v_sub2 = XSIMath.CreateVector3()
	v_sub1.Sub(v_ankle, v_fball)
	v_sub2.Sub(v_ankle, v_fend)
	v_plain.Cross( v_sub1, v_sub2 )
	
	root_lfoot = mdl_rig.Add2DChain( v_ankle, v_fball, v_plain, c.si2DChainNormalRadian, 'foot_Lft_Chn' )
	root_lfoot = dispFix( root_lfoot )
	root_lfoot.effector.Name = 'foot_Lft_Eff'
	root_lfoot.Bones(0).Name = 'foot_Lft_Bone'
	root_lfoot.AddBone( v_fend, c.siChainBonePin, 'toes_Lft_Bone' )
	
	formatChain( root_lfoot )
	
	########################################
	# build right foot 
	#
	
	v_ankle.X = v_ankle.X * -1
	v_fball.X = v_fball.X * -1
	v_fend.X = v_fend.X * -1
	
	# calculate the normal plain #
	v_plain = XSIMath.CreateVector3()
	v_sub1 = XSIMath.CreateVector3()
	v_sub2 = XSIMath.CreateVector3()
	v_sub1.Sub(v_ankle, v_fball)
	v_sub2.Sub(v_ankle, v_fend)
	v_plain.Cross( v_sub1, v_sub2 )
	
	root_rfoot = mdl_rig.Add2DChain( v_ankle, v_fball, v_plain, c.si2DChainNormalRadian, 'foot_Rgt_Chn' )
	root_rfoot = dispFix( root_rfoot )
	root_rfoot.effector.Name = 'foot_Rgt_Eff'
	root_rfoot.Bones(0).Name = 'foot_Rgt_Bone'
	root_rfoot.AddBone( v_fend, c.siChainBonePin, 'toes_Rgt_Bone' )
	
	formatChain( root_rfoot )
	
	########################################
	# build left toes
	#
	
	for i in range(1,6):
		
		col = win32com.client.Dispatch( 'XSI.Collection' )
		col.SetAsText( '%s.%s' % ( model_lm.Fullname,
								   dict_lm['toe%sprx'%i]['Lft']) )
		lm_toeprx = col(0)
		
		col.SetAsText( '%s.%s' % ( model_lm.Fullname,
								   dict_lm['toe%smid'%i]['Lft']) )
		lm_toemid = col(0)

		lm_toedst = None
		if i != 1:
			col.SetAsText( '%s.%s' % ( model_lm.Fullname,
									   dict_lm['toe%sdst'%i]['Lft']) )
			lm_toedst = col(0)
		
		col.SetAsText( '%s.%s' % ( model_lm.Fullname,
								   dict_lm['toe%send'%i]['Lft']) )
		lm_toeend = col(0)

		# get the vectors #
		v_toeprx = XSIMath.CreateVector3()
		v_toemid = XSIMath.CreateVector3()
		v_toedst = XSIMath.CreateVector3()
		v_toeend = XSIMath.CreateVector3()
		
		lm_toeprx.Kinematics.Global.Transform.GetTranslation( v_toeprx )
		lm_toemid.Kinematics.Global.Transform.GetTranslation( v_toemid )
		if i != 1: 
			lm_toedst.Kinematics.Global.Transform.GetTranslation( v_toedst )
		lm_toeend.Kinematics.Global.Transform.GetTranslation( v_toeend )
	
		# calculate the normal plain #
		tfrm = lm_toeprx.Kinematics.Local.Transform
		tfrm.AddLocalTranslation( XSIMath.CreateVector3(1, 0, 0) )
		v_hack = XSIMath.CreateVector3()
		tfrm.GetTranslation( v_hack )
		v_plain = XSIMath.CreateVector3()
		v_plain.Sub( v_toeprx, v_hack )
		

		# build the chain #
		root_ltoe = mdl_rig.Add2DChain( v_toeprx, v_toemid, v_plain, c.si2DChainNormalRadian, 
										'toe%s_Lft_Chn'%i )
		root_ltoe = dispFix( root_ltoe )
		root_ltoe.effector.Name = 'toe%s_Lft_Eff'%i
		root_ltoe.Bones(0).Name = 'toe%sprx_Lft_Bone'%i
		if i==1:
			root_ltoe.AddBone( v_toeend, c.siChainBonePin, 'toe%smid_Lft_Bone'%i )
		else:
			root_ltoe.AddBone( v_toedst, c.siChainBonePin, 'toe%smid_Lft_Bone'%i )
			root_ltoe.AddBone( v_toeend, c.siChainBonePin, 'toe%sdst_Lft_Bone'%i )
		
		root_ltoe.Kinematics.Global.Transform = lm_toeprx.Kinematics.Global.Transform
		root_ltoe.Bones(0).Kinematics.Global.Transform = lm_toeprx.Kinematics.Global.Transform
		root_ltoe.Bones(1).Kinematics.Global.Transform = lm_toemid.Kinematics.Global.Transform
		if root_ltoe.Bones.Count > 2: 
			root_ltoe.Bones(2).Kinematics.Global.Transform = lm_toedst.Kinematics.Global.Transform
		
		formatChain( root_ltoe, .2 )

	########################################
	# build right toes
	#
	
	for i in range(1,6):
		
		col = win32com.client.Dispatch( 'XSI.Collection' )
		col.SetAsText( '%s.%s' % ( model_lm.Fullname,
								   dict_lm['toe%sprx'%i]['Lft']) )
		lm_toeprx = col(0)
		lm_toeprx = xsi.Duplicate( col, 1, None, None, None, None, None, c.siNoConstraints )(0)
		
		col.SetAsText( '%s.%s' % ( model_lm.Fullname,
								   dict_lm['toe%smid'%i]['Lft']) )
		lm_toemid = col(0)
		lm_toemid = xsi.Duplicate( col, 1, None, None, None, None, None, c.siNoConstraints )(0)

		lm_toedst = None
		if i != 1:
			col.SetAsText( '%s.%s' % ( model_lm.Fullname,
									   dict_lm['toe%sdst'%i]['Lft']) )
			lm_toedst = col(0)
			lm_toedst = xsi.Duplicate( col, 1, None, None, None, None, None, c.siNoConstraints )(0)
		
		col.SetAsText( '%s.%s' % ( model_lm.Fullname,
								   dict_lm['toe%send'%i]['Lft']) )
		lm_toeend = col(0)
		lm_toeend = xsi.Duplicate( col, 1, None, None, None, None, None, c.siNoConstraints )(0)

		# symmetry #
		rt = XSIMath.CreateRotation()
		rt.SetFromXYZAnglesValues( 0, 0, XSIMath.DegreesToRadians( 180 ) )
		
		m_inv = XSIMath.CreateMatrix4()
		mv = m_inv.Get2()
		m_inv.Set( float(-1),  mv[1],  mv[2],  mv[3],
				   mv[4],  mv[5],  mv[6],  mv[7],
				   mv[8],  mv[9],  mv[10], mv[11],
				   mv[12], mv[13], mv[14], mv[15] )
		
		m = XSIMath.CreateMatrix4()
		
		t = lm_toeprx.Kinematics.Global.Transform
		t.GetMatrix4( m )
		m.MulInPlace( m_inv )
		t.SetMatrix4( m )
		t.AddLocalRotation( rt )
		lm_toeprx.Kinematics.Global.Transform = t
		
		t = lm_toemid.Kinematics.Global.Transform
		t.GetMatrix4( m )
		m.MulInPlace( m_inv )
		t.SetMatrix4( m )
		t.AddLocalRotation( rt )
		lm_toemid.Kinematics.Global.Transform = t
		
		if i != 1:
			t = lm_toedst.Kinematics.Global.Transform
			t.GetMatrix4( m )
			m.MulInPlace( m_inv )
			t.SetMatrix4( m )
			t.AddLocalRotation( rt )
			lm_toedst.Kinematics.Global.Transform = t
		
		t = lm_toeend.Kinematics.Global.Transform
		t.GetMatrix4( m )
		m.MulInPlace( m_inv )
		t.SetMatrix4( m )
		t.AddLocalRotation( rt )
		lm_toeend.Kinematics.Global.Transform = t
		
		xsi.ResetTransform( lm_toeprx.Fullname, 'siCtr', 'siScl', 'siXYZ' )
		xsi.ResetTransform( lm_toemid.Fullname, 'siCtr', 'siScl', 'siXYZ' )
		if i != 1:
			xsi.ResetTransform( lm_toedst.Fullname, 'siCtr', 'siScl', 'siXYZ' )
		xsi.ResetTransform( lm_toeend.Fullname, 'siCtr', 'siScl', 'siXYZ' )
		
		
		# get the vectors #
		v_toeprx = XSIMath.CreateVector3()
		v_toemid = XSIMath.CreateVector3()
		v_toedst = XSIMath.CreateVector3()
		v_toeend = XSIMath.CreateVector3()
		
		lm_toeprx.Kinematics.Global.Transform.GetTranslation( v_toeprx )
		lm_toemid.Kinematics.Global.Transform.GetTranslation( v_toemid )
		if i != 1: 
			lm_toedst.Kinematics.Global.Transform.GetTranslation( v_toedst )
		lm_toeend.Kinematics.Global.Transform.GetTranslation( v_toeend )
		
		# symetry the vector #
		v_toeprx.X = v_toeprx.X * -1
		v_toemid.X = v_toemid.X * -1
		v_toedst.X = v_toedst.X * -1
		v_toeend.X = v_toeend.X * -1
	
		# calculate the normal plain #
		tfrm = lm_toeprx.Kinematics.Local.Transform
		tfrm.AddLocalTranslation( XSIMath.CreateVector3(1, 0, 0) )
		v_hack = XSIMath.CreateVector3()
		tfrm.GetTranslation( v_hack )
		v_plain = XSIMath.CreateVector3()
		v_plain.Sub( v_toeprx, v_hack )
		

		# build the chain #
		root_ltoe = mdl_rig.Add2DChain( v_toeprx, v_toemid, v_plain, c.si2DChainNormalRadian, 
										'toe%s_Rgt_Chn'%i )
		root_ltoe = dispFix( root_ltoe )
		root_ltoe.effector.Name = 'toe%s_Rgt_Eff'%i
		root_ltoe.Bones(0).Name = 'toe%sprx_Rgt_Bone'%i
		if i==1:
			root_ltoe.AddBone( v_toeend, c.siChainBonePin, 'toe%smid_Rgt_Bone'%i )
		else:
			root_ltoe.AddBone( v_toedst, c.siChainBonePin, 'toe%smid_Rgt_Bone'%i )
			root_ltoe.AddBone( v_toeend, c.siChainBonePin, 'toe%sdst_Rgt_Bone'%i )
		
		root_ltoe.Kinematics.Global.Transform = lm_toeprx.Kinematics.Global.Transform
		root_ltoe.Bones(0).Kinematics.Global.Transform = lm_toeprx.Kinematics.Global.Transform
		if root_ltoe.Bones.Count > 2: 
			root_ltoe.Bones(1).Kinematics.Global.Transform = lm_toemid.Kinematics.Global.Transform
			root_ltoe.Bones(2).Kinematics.Global.Transform = lm_toedst.Kinematics.Global.Transform
		else:
			root_ltoe.Bones(1).Kinematics.Global.Transform = lm_toemid.Kinematics.Global.Transform

		formatChain( root_ltoe, .2 )

	
		
	########################################
	# build pelvis
	#
	col = win32com.client.Dispatch( 'XSI.Collection' )
	col.SetAsText( '%s.%s' % ( model_lm.Fullname,
							   dict_lm['pelvis']['None']) )
	lm_pelvis = col(0)

	v_plvs = XSIMath.CreateVector3()
	lm_pelvis.Kinematics.Global.Transform.GetTranslation( v_plvs )
	
	# add in 2 local units in z #
	t = lm_pelvis.Kinematics.Global.Transform
	v = XSIMath.CreateVector3( 0, -1, 1.25 )
	t.AddLocalTranslation( v )
	v_end = XSIMath.CreateVector3()
	t.GetTranslation( v_end )
	
	root_pelvis = mdl_rig.Add2DChain( v_plvs, v_end, v_plain, c.si2DChainRight, 'pelvis_Mid_Chn' )
	root_pelvis = dispFix( root_pelvis )
	root_pelvis.bones(0).Name = 'pelvis_Mid_Bone'
	root_pelvis.effector.Name = 'pelvis_Mid_Eff'
	
	formatChain( root_pelvis )
		
	########################################
	# build head
	#
	col = win32com.client.Dispatch( 'XSI.Collection' )
	col.SetAsText( '%s.%s' % ( model_lm.Fullname,
							   dict_lm['headBase']['None']) )
	lm_head = col(0)

	col = win32com.client.Dispatch( 'XSI.Collection' )
	col.SetAsText( '%s.%s' % ( model_lm.Fullname,
							   dict_lm['headEnd']['None']) )
	lm_end = col(0)

	v_head = XSIMath.CreateVector3()
	v_hend  = XSIMath.CreateVector3()
	lm_head.Kinematics.Global.Transform.GetTranslation( v_head )
	lm_end.Kinematics.Global.Transform.GetTranslation( v_hend )
	
	# calculate the normal plain #
	v_plain = XSIMath.CreateVector3()
	v_sub1 = XSIMath.CreateVector3()
	v_sub2 = XSIMath.CreateVector3()
	v_sub1.Sub( v_head, v_hend )
	v_sub2.Copy( v_sub1 )
	v_plain.Cross( v_sub1, v_sub2 )
	
	
	root_head = mdl_rig.Add2DChain( v_head, v_hend, v_plain, c.si2DChainRight, 'head_Mid_Chn' )
	root_head = dispFix( root_head )
	root_head.bones(0).Name = 'head_Mid_Bone'
	root_head.effector.Name = 'head_Mid_Eff'
	
	formatChain( root_head )
		
	########################################
	# build clavicle
	#
	col = win32com.client.Dispatch( 'XSI.Collection' )
	col.SetAsText( '%s.%s' % ( model_lm.Fullname,
							   dict_lm['clavicle']['Lft']) )
	lm_lclav = col(0)

	col = win32com.client.Dispatch( 'XSI.Collection' )
	col.SetAsText( '%s.%s' % ( model_lm.Fullname,
							   dict_lm['shoulder']['Lft']) )
	lm_lshldr = col(0)

	v_lclav = XSIMath.CreateVector3()
	v_lshldr  = XSIMath.CreateVector3()
	lm_lclav.Kinematics.Global.Transform.GetTranslation( v_lclav )
	lm_lshldr.Kinematics.Global.Transform.GetTranslation( v_lshldr )
	
	# calculate the normal plain #
	v_plain = XSIMath.CreateVector3()
#	v_sub1 = XSIMath.CreateVector3()
#	v_sub2 = XSIMath.CreateVector3()
#	v_sub1.Sub( v_head, v_hend )
#	v_sub2.Copy( v_sub1 )
#	v_plain.Cross( v_sub1, v_sub2 )
	
	
	root_lclav = mdl_rig.Add2DChain( v_lclav, v_lshldr, v_plain, c.si2DChainFront, 'clavicle_Lft_Chn' )
	root_lclav = dispFix( root_lclav )
	root_lclav.bones(0).Name = 'clavicle_Lft_Bone'
	root_lclav.effector.Name = 'clavicle_Lft_Eff'
	
	formatChain( root_lclav )
	
	########################################
	# build clavicle right
	#
	v_rclav = XSIMath.CreateVector3()
	v_rshldr  = XSIMath.CreateVector3()
	lm_lclav.Kinematics.Global.Transform.GetTranslation( v_rclav )
	lm_lshldr.Kinematics.Global.Transform.GetTranslation( v_rshldr )
	
	v_rclav.X  = v_rclav.X * -1
	v_rshldr.X = v_rshldr.X * -1
	
	root_rclav = mdl_rig.Add2DChain( v_rclav, v_rshldr, v_plain, c.si2DChainFront, 'clavicle_Rgt_Chn' )
	root_rclav = dispFix( root_rclav )
	root_rclav.bones(0).Name = 'clavicle_Rgt_Bone'
	root_rclav.effector.Name = 'clavicle_Rgt_Eff'
	
	formatChain( root_rclav )
		
		
	########################################
	# build arm left
	#
	col.SetAsText( '%s.%s' % ( model_lm.Fullname,
							   dict_lm['shoulder']['Lft']) )
	lm_lshldr = col(0)

	col.SetAsText( '%s.%s' % ( model_lm.Fullname,
							   dict_lm['elbow']['Lft']) )
	lm_lelbw = col(0)

	col.SetAsText( '%s.%s' % ( model_lm.Fullname,
							   dict_lm['wrist']['Lft']) )
	lm_lwrst = col(0)

	v_lshldr  = XSIMath.CreateVector3()
	lm_lshldr.Kinematics.Global.Transform.GetTranslation( v_lshldr )
	v_lelbw  = XSIMath.CreateVector3()
	lm_lelbw.Kinematics.Global.Transform.GetTranslation( v_lelbw )
	v_lwrst  = XSIMath.CreateVector3()
	lm_lwrst.Kinematics.Global.Transform.GetTranslation( v_lwrst )
	
	# calculate the normal plain #
	v_plain = XSIMath.CreateVector3()
	v_sub1 = XSIMath.CreateVector3()
	v_sub2 = XSIMath.CreateVector3()
	v_sub1.Sub( v_lshldr, v_lelbw )
	v_sub2.Sub( v_lshldr, v_lwrst )
	v_plain.Cross( v_sub2, v_sub1 )
	
	
	root_larm = mdl_rig.Add2DChain( v_lshldr, v_lelbw, v_plain, c.si2DChainNormalRadian, 'arm_Lft_Chn' )
	root_larm = dispFix( root_larm )
	root_larm.effector.Name = 'arm_Lft_Eff'
	root_larm.Bones(0).Name = 'bicep_Lft_Bone'
	root_larm.AddBone( v_lwrst, c.siChainBonePin, 'forearm_Lft_Bone' )
	
	
	formatChain( root_larm )
	
	########################################
	# build hand left
	#
	col = win32com.client.Dispatch( 'XSI.Collection' )
	col.SetAsText( '%s.%s' % ( model_lm.Fullname,
							   dict_lm['wrist']['Lft']) )
	lm_lwrst = col(0)

	col = win32com.client.Dispatch( 'XSI.Collection' )
	col.SetAsText( '%s.%s' % ( model_lm.Fullname,
							   dict_lm['hand']['Lft']) )
	lm_lhand = col(0)

	v_lwrst  = XSIMath.CreateVector3()
	lm_lwrst.Kinematics.Global.Transform.GetTranslation( v_lwrst )
	v_lhand  = XSIMath.CreateVector3()
	lm_lhand.Kinematics.Global.Transform.GetTranslation( v_lhand )
	
	# calculate the normal plain #
	v_up  = XSIMath.CreateVector3()
	t = lm_lwrst.Kinematics.Global.Transform
	t.AddLocalTranslation( XSIMath.CreateVector3( 0, 2, 0 ) )
	t.GetTranslation( v_up )
	
	v_plain = XSIMath.CreateVector3()
	v_sub1 = XSIMath.CreateVector3()
	v_sub2 = XSIMath.CreateVector3()
	v_sub1.Sub( v_lwrst, v_lhand )
	v_sub2.Sub( v_lwrst, v_up )
	v_plain.Cross( v_sub1, v_sub2 )
	
	
	root_lhand = mdl_rig.Add2DChain( v_lwrst, v_lhand, v_plain, c.si2DChainNormalRadian, 'hand_Lft_Chn' )
	root_lhand = dispFix( root_lhand )
	root_lhand.bones(0).Name = 'hand_Lft_Bone'
	root_lhand.effector.Name = 'hand_Lft_Eff'
	
	formatChain( root_lhand )
		
	########################################
	# build arm right
	#
	col.SetAsText( '%s.%s' % ( model_lm.Fullname,
							   dict_lm['shoulder']['Lft']) )
	lm_lshldr = col(0)

	col.SetAsText( '%s.%s' % ( model_lm.Fullname,
							   dict_lm['elbow']['Lft']) )
	lm_lelbw = col(0)

	col.SetAsText( '%s.%s' % ( model_lm.Fullname,
							   dict_lm['wrist']['Lft']) )
	lm_lwrst = col(0)

	v_rshldr  = XSIMath.CreateVector3()
	lm_lshldr.Kinematics.Global.Transform.GetTranslation( v_rshldr )
	v_relbw  = XSIMath.CreateVector3()
	lm_lelbw.Kinematics.Global.Transform.GetTranslation( v_relbw )
	v_rwrst  = XSIMath.CreateVector3()
	lm_lwrst.Kinematics.Global.Transform.GetTranslation( v_rwrst )
	
	v_rshldr.X = v_rshldr.X * -1
	v_relbw.X  = v_relbw.X * -1
	v_rwrst.X  = v_rwrst.X * -1
	
	# calculate the normal plain #
	v_plain = XSIMath.CreateVector3()
	v_sub1 = XSIMath.CreateVector3()
	v_sub2 = XSIMath.CreateVector3()
	v_sub1.Sub( v_rshldr, v_relbw )
	v_sub2.Sub( v_rshldr, v_rwrst )
	v_plain.Cross( v_sub2, v_sub1 )
	
	
	root_rarm = mdl_rig.Add2DChain( v_rshldr, v_relbw, v_plain, c.si2DChainNormalRadian, 'arm_Rgt_Chn' )
	root_rarm = dispFix( root_rarm )
	root_rarm.effector.Name = 'arm_Rgt_Eff'
	root_rarm.Bones(0).Name = 'bicep_Rgt_Bone'
	root_rarm.AddBone( v_rwrst, c.siChainBonePin, 'forearm_Rgt_Bone' )
	
	
	formatChain( root_rarm )
	
	########################################
	# build hand right
	#
	col = win32com.client.Dispatch( 'XSI.Collection' )
	col.SetAsText( '%s.%s' % ( model_lm.Fullname,
							   dict_lm['wrist']['Lft']) )
	lm_lwrst = col(0)

	col = win32com.client.Dispatch( 'XSI.Collection' )
	col.SetAsText( '%s.%s' % ( model_lm.Fullname,
							   dict_lm['hand']['Lft']) )
	lm_lhand = col(0)

	v_rwrst  = XSIMath.CreateVector3()
	lm_lwrst.Kinematics.Global.Transform.GetTranslation( v_rwrst )
	v_rhand  = XSIMath.CreateVector3()
	lm_lhand.Kinematics.Global.Transform.GetTranslation( v_rhand )
	
	v_rwrst.X = v_rwrst.X * -1
	v_rhand.X = v_rhand.X * -1
	
	# calculate the normal plain #
	v_up  = XSIMath.CreateVector3()
	t = lm_lwrst.Kinematics.Global.Transform
	t.AddLocalTranslation( XSIMath.CreateVector3( 2, 0, 0 ) )
	t.GetTranslation( v_up )
	
	v_plain = XSIMath.CreateVector3()
	v_sub1 = XSIMath.CreateVector3()
	v_sub2 = XSIMath.CreateVector3()
	v_sub1.Sub( v_rwrst, v_rhand )
	v_sub2.Sub( v_rwrst, v_up )
	v_plain.Cross( v_sub2, v_sub1 )
	
	
	root_rhand = mdl_rig.Add2DChain( v_rwrst, v_rhand, v_plain, c.si2DChainNormalRadian, 'hand_Rgt_Chn' )
	root_rhand = dispFix( root_rhand )
	root_rhand.bones(0).Name = 'hand_Rgt_Bone'
	root_rhand.effector.Name = 'hand_Rgt_Eff'
	
	formatChain( root_rhand )


	########################################
	# build thumb left
	#
	col.SetAsText( '%s.%s' % ( model_lm.Fullname,
							   dict_lm['thumbmet']['Lft']) )
	lm_ltmet = col(0)

	col.SetAsText( '%s.%s' % ( model_lm.Fullname,
							   dict_lm['thumbprx']['Lft']) )
	lm_ltprx = col(0)

	col.SetAsText( '%s.%s' % ( model_lm.Fullname,
							   dict_lm['thumbmid']['Lft']) )
	lm_ltmid = col(0)

	col.SetAsText( '%s.%s' % ( model_lm.Fullname,
							   dict_lm['thumbend']['Lft']) )
	lm_ltend = col(0)


	v_ltmet  = XSIMath.CreateVector3()
	lm_ltmet.Kinematics.Global.Transform.GetTranslation( v_ltmet )
	v_ltprx  = XSIMath.CreateVector3()
	lm_ltprx.Kinematics.Global.Transform.GetTranslation( v_ltprx )
	v_ltmid  = XSIMath.CreateVector3()
	lm_ltmid.Kinematics.Global.Transform.GetTranslation( v_ltmid )
	v_ltend  = XSIMath.CreateVector3()
	lm_ltend.Kinematics.Global.Transform.GetTranslation( v_ltend )

	# calculate the normal plain #
	v_plain = XSIMath.CreateVector3()
	v_sub1 = XSIMath.CreateVector3()
	v_sub2 = XSIMath.CreateVector3()
	v_sub1.Sub( v_ltmet, v_ltprx )
	v_sub2.Sub( v_ltmet, v_ltend )
	v_plain.Cross( v_sub2, v_sub1 )
	
	
	root_lthmb = mdl_rig.Add2DChain( v_ltmet, v_ltprx, v_plain, c.si2DChainNormalRadian, 'thumb_Lft_Chn' )
	root_lthmb = dispFix( root_lthmb )
	root_lthmb.effector.Name = 'thumb_Lft_Eff'
	root_lthmb.Bones(0).Name = 'thumbmet_Lft_Bone'
	root_lthmb.AddBone( v_ltmid, c.siChainBonePin, 'thumbprx_Lft_Bone' )
	root_lthmb.AddBone( v_ltend, c.siChainBonePin, 'thumbmid_Lft_Bone' )
	
	root_lthmb.Kinematics.Global.Transform = lm_ltmet.Kinematics.Global.Transform
	root_lthmb.Bones(0).Kinematics.Global.Transform = lm_ltmet.Kinematics.Global.Transform
	root_lthmb.Bones(1).Kinematics.Global.Transform = lm_ltprx.Kinematics.Global.Transform
	root_lthmb.Bones(2).Kinematics.Global.Transform = lm_ltmid.Kinematics.Global.Transform
	
	formatChain( root_lthmb, 0.2 )

	########################################
	# build left fingers
	#
	
	for i in range(2,6):
		
		col = win32com.client.Dispatch( 'XSI.Collection' )
		col.SetAsText( '%s.%s' % ( model_lm.Fullname,
								   dict_lm['fing%sprx'%i]['Lft']) )
		lm_fingprx = col(0)
		
		col = win32com.client.Dispatch( 'XSI.Collection' )
		col.SetAsText( '%s.%s' % ( model_lm.Fullname,
								   dict_lm['fing%smid'%i]['Lft']) )
		lm_fingmid = col(0)

		col = win32com.client.Dispatch( 'XSI.Collection' )
		col.SetAsText( '%s.%s' % ( model_lm.Fullname,
								   dict_lm['fing%sdst'%i]['Lft']) )
		lm_fingdst = col(0)
		
		col = win32com.client.Dispatch( 'XSI.Collection' )
		col.SetAsText( '%s.%s' % ( model_lm.Fullname,
								   dict_lm['fing%send'%i]['Lft']) )
		lm_fingend = col(0)

		# get the vectors #
		v_fingprx = XSIMath.CreateVector3()
		v_fingmid = XSIMath.CreateVector3()
		v_fingdst = XSIMath.CreateVector3()
		v_fingend = XSIMath.CreateVector3()
		
		lm_fingprx.Kinematics.Global.Transform.GetTranslation( v_fingprx )
		lm_fingmid.Kinematics.Global.Transform.GetTranslation( v_fingmid )
		lm_fingdst.Kinematics.Global.Transform.GetTranslation( v_fingdst )
		lm_fingend.Kinematics.Global.Transform.GetTranslation( v_fingend )
		
		# calculate the normal plain #
		v_plain = XSIMath.CreateVector3()
		v_sub1 = XSIMath.CreateVector3()
		v_sub2 = XSIMath.CreateVector3()
		v_sub1.Sub( v_fingprx, v_fingmid )
		v_sub2.Sub( v_fingprx, v_fingend )
		v_plain.Cross( v_sub2, v_sub1 )
	
		# build the chain #
		root_fing = mdl_rig.Add2DChain( v_fingprx, v_fingmid, v_plain, c.si2DChainNormalRadian, 
										'fing%s_Lft_Chn'%i )
		root_fing = dispFix( root_fing )
		root_fing.effector.Name = 'fing%s_Lft_Eff'%i
		root_fing.Bones(0).Name = 'fing%sprx_Lft_Bone'%i
		root_fing.AddBone( v_fingdst, c.siChainBonePin, 'fing%smid_Lft_Bone'%i )
		root_fing.AddBone( v_fingend, c.siChainBonePin, 'fing%sdst_Lft_Bone'%i )
		
		root_fing.Kinematics.Global.Transform = lm_fingprx.Kinematics.Global.Transform
		root_fing.Bones(0).Kinematics.Global.Transform = lm_fingprx.Kinematics.Global.Transform
		root_fing.Bones(1).Kinematics.Global.Transform = lm_fingmid.Kinematics.Global.Transform
		root_fing.Bones(2).Kinematics.Global.Transform = lm_fingdst.Kinematics.Global.Transform
	
		formatChain( root_fing, .2 )
		
		
	########################################
	# build thumb right
	#
	col.SetAsText( '%s.%s' % ( model_lm.Fullname,
							   dict_lm['thumbmet']['Lft']) )
	lm_ltmet = col(0)
	lm_ltmet = xsi.Duplicate( col, 1, None, None, None, None, None, c.siNoConstraints )(0)

	col.SetAsText( '%s.%s' % ( model_lm.Fullname,
							   dict_lm['thumbprx']['Lft']) )
	lm_ltprx = col(0)
	lm_ltprx = xsi.Duplicate( col, 1, None, None, None, None, None, c.siNoConstraints )(0)

	col.SetAsText( '%s.%s' % ( model_lm.Fullname,
							   dict_lm['thumbmid']['Lft']) )
	lm_ltmid = col(0)
	lm_ltmid = xsi.Duplicate( col, 1, None, None, None, None, None, c.siNoConstraints )(0)

	col.SetAsText( '%s.%s' % ( model_lm.Fullname,
							   dict_lm['thumbend']['Lft']) )
	lm_ltend = col(0)
	lm_ltend = xsi.Duplicate( col, 1, None, None, None, None, None, c.siNoConstraints )(0)

	rt = XSIMath.CreateRotation()
	rt.SetFromXYZAnglesValues( 0, 0, XSIMath.DegreesToRadians( 180 ) )
	
	m_inv = XSIMath.CreateMatrix4()
	mv = m_inv.Get2()
	m_inv.Set( float(-1),  mv[1],  mv[2],  mv[3],
			   mv[4],  mv[5],  mv[6],  mv[7],
			   mv[8],  mv[9],  mv[10], mv[11],
			   mv[12], mv[13], mv[14], mv[15] )
	
	m = XSIMath.CreateMatrix4()
	
	t = lm_ltmet.Kinematics.Global.Transform
	t.GetMatrix4( m )
	m.MulInPlace( m_inv )
	t.SetMatrix4( m )
	t.AddLocalRotation( rt )
	lm_ltmet.Kinematics.Global.Transform = t
		
	t = lm_ltprx.Kinematics.Global.Transform
	t.GetMatrix4( m )
	m.MulInPlace( m_inv )
	t.SetMatrix4( m )
	t.AddLocalRotation( rt )
	lm_ltprx.Kinematics.Global.Transform = t
		
	t = lm_ltmid.Kinematics.Global.Transform
	t.GetMatrix4( m )
	m.MulInPlace( m_inv )
	t.SetMatrix4( m )
	t.AddLocalRotation( rt )
	lm_ltmid.Kinematics.Global.Transform = t

	t = lm_ltend.Kinematics.Global.Transform
	t.GetMatrix4( m )
	m.MulInPlace( m_inv )
	t.SetMatrix4( m )
	t.AddLocalRotation( rt )
	lm_ltend.Kinematics.Global.Transform = t

	xsi.ResetTransform( lm_ltmet.Fullname, 'siCtr', 'siScl', 'siXYZ' )
	xsi.ResetTransform( lm_ltprx.Fullname, 'siCtr', 'siScl', 'siXYZ' )
	xsi.ResetTransform( lm_ltmid.Fullname, 'siCtr', 'siScl', 'siXYZ' )
	xsi.ResetTransform( lm_ltend.Fullname, 'siCtr', 'siScl', 'siXYZ' )
	
	v_rtmet  = XSIMath.CreateVector3()
	lm_ltmet.Kinematics.Global.Transform.GetTranslation( v_rtmet )
	v_rtprx  = XSIMath.CreateVector3()
	lm_ltprx.Kinematics.Global.Transform.GetTranslation( v_rtprx )
	v_rtmid  = XSIMath.CreateVector3()
	lm_ltmid.Kinematics.Global.Transform.GetTranslation( v_rtmid )
	v_rtend  = XSIMath.CreateVector3()
	lm_ltend.Kinematics.Global.Transform.GetTranslation( v_rtend )
	
#	v_rtmet.X = v_rtmet.X * -1
#	v_rtprx.X = v_rtprx.X * -1
#	v_rtmid.X = v_rtmid.X * -1
#	v_rtend.X = v_rtend.X * -1
	

	# calculate the normal plain #
	v_plain = XSIMath.CreateVector3()
	v_sub1 = XSIMath.CreateVector3()
	v_sub2 = XSIMath.CreateVector3()
	v_sub1.Sub( v_rtmet, v_rtprx )
	v_sub2.Sub( v_rtmet, v_rtend )
	v_plain.Cross( v_sub2, v_sub1 )
	
	
	root_rthmb = mdl_rig.Add2DChain( v_rtmet, v_rtprx, v_plain, c.si2DChainNormalRadian, 'thumb_Rgt_Chn' )
	root_rthmb = dispFix( root_rthmb )
	root_rthmb.effector.Name = 'thumb_Rgt_Eff'
	root_rthmb.Bones(0).Name = 'thumbmet_Rgt_Bone'
	root_rthmb.AddBone( v_rtmid, c.siChainBonePin, 'thumbprx_Rgt_Bone' )
	root_rthmb.AddBone( v_rtend, c.siChainBonePin, 'thumbmid_Rgt_Bone' )
	
	root_rthmb.Kinematics.Global.Transform = lm_ltmet.Kinematics.Global.Transform
	root_rthmb.Bones(0).Kinematics.Global.Transform = lm_ltmet.Kinematics.Global.Transform
	root_rthmb.Bones(1).Kinematics.Global.Transform = lm_ltprx.Kinematics.Global.Transform
	root_rthmb.Bones(2).Kinematics.Global.Transform = lm_ltmid.Kinematics.Global.Transform

	formatChain( root_rthmb, 0.2 )

	########################################
	# build right fingers
	#
	
	for i in range(2,6):
		
		col = win32com.client.Dispatch( 'XSI.Collection' )
		col.SetAsText( '%s.%s' % ( model_lm.Fullname,
								   dict_lm['fing%sprx'%i]['Lft']) )
		
		lm_fingprx = col(0)
		lm_fingprx = xsi.Duplicate( col, 1, None, None, None, None, None, c.siNoConstraints )(0)
		
		col = win32com.client.Dispatch( 'XSI.Collection' )
		col.SetAsText( '%s.%s' % ( model_lm.Fullname,
								   dict_lm['fing%smid'%i]['Lft']) )
		lm_fingmid = col(0)
		lm_fingmid = xsi.Duplicate( col, 1, None, None, None, None, None, c.siNoConstraints )(0)

		col = win32com.client.Dispatch( 'XSI.Collection' )
		col.SetAsText( '%s.%s' % ( model_lm.Fullname,
								   dict_lm['fing%sdst'%i]['Lft']) )
		lm_fingdst = col(0)
		lm_fingdst = xsi.Duplicate( col, 1, None, None, None, None, None, c.siNoConstraints )(0)
		
		col = win32com.client.Dispatch( 'XSI.Collection' )
		col.SetAsText( '%s.%s' % ( model_lm.Fullname,
								   dict_lm['fing%send'%i]['Lft']) )
		lm_fingend = col(0)
		lm_fingend = xsi.Duplicate( col, 1, None, None, None, None, None, c.siNoConstraints )(0)

		# get the vectors #
		v_fingprx = XSIMath.CreateVector3()
		v_fingmid = XSIMath.CreateVector3()
		v_fingdst = XSIMath.CreateVector3()
		v_fingend = XSIMath.CreateVector3()
		
		rt = XSIMath.CreateRotation()
		rt.SetFromXYZAnglesValues( 0, 0, XSIMath.DegreesToRadians( 180 ) )
		
		m_inv = XSIMath.CreateMatrix4()
		mv = m_inv.Get2()
		m_inv.Set( float(-1),  mv[1],  mv[2],  mv[3],
				   mv[4],  mv[5],  mv[6],  mv[7],
				   mv[8],  mv[9],  mv[10], mv[11],
				   mv[12], mv[13], mv[14], mv[15] )
		
		m = XSIMath.CreateMatrix4()
		t = lm_fingprx.Kinematics.Global.Transform
		t.GetMatrix4( m )
		m.MulInPlace( m_inv )
		t.SetMatrix4( m )
		t.AddLocalRotation( rt )
		lm_fingprx.Kinematics.Global.Transform = t
		
		t = lm_fingmid.Kinematics.Global.Transform
		t.GetMatrix4( m )
		m.MulInPlace( m_inv )
		t.SetMatrix4( m )
		t.AddLocalRotation( rt )
		lm_fingmid.Kinematics.Global.Transform = t
		
		t = lm_fingdst.Kinematics.Global.Transform
		t.GetMatrix4( m )
		m.MulInPlace( m_inv )
		t.SetMatrix4( m )
		t.AddLocalRotation( rt )
		lm_fingdst.Kinematics.Global.Transform = t
		
		t = lm_fingend.Kinematics.Global.Transform
		t.GetMatrix4( m )
		m.MulInPlace( m_inv )
		t.SetMatrix4( m )
		t.AddLocalRotation( rt )
		lm_fingend.Kinematics.Global.Transform = t
		
		xsi.ResetTransform( lm_fingprx.Fullname, 'siCtr', 'siScl', 'siXYZ' )
		xsi.ResetTransform( lm_fingmid.Fullname, 'siCtr', 'siScl', 'siXYZ' )
		xsi.ResetTransform( lm_fingdst.Fullname, 'siCtr', 'siScl', 'siXYZ' )
		xsi.ResetTransform( lm_fingend.Fullname, 'siCtr', 'siScl', 'siXYZ' )
		
		lm_fingprx.Kinematics.Global.Transform.GetTranslation( v_fingprx )
		lm_fingmid.Kinematics.Global.Transform.GetTranslation( v_fingmid )
		lm_fingdst.Kinematics.Global.Transform.GetTranslation( v_fingdst )
		lm_fingend.Kinematics.Global.Transform.GetTranslation( v_fingend )
		
		# calculate the normal plain #
		v_plain = XSIMath.CreateVector3()
		v_sub1 = XSIMath.CreateVector3()
		v_sub2 = XSIMath.CreateVector3()
		v_sub1.Sub( v_fingprx, v_fingmid )
		v_sub2.Sub( v_fingprx, v_fingend )
		v_plain.Cross( v_sub2, v_sub1 )
	
		# build the chain #
		root_fing = mdl_rig.Add2DChain( v_fingprx, v_fingmid, v_plain, c.si2DChainNormalRadian, 
										'fing%s_Rgt_Chn'%i )
		root_fing = dispFix( root_fing )
		root_fing.effector.Name = 'fing%s_Rgt_Eff'%i
		root_fing.Bones(0).Name = 'fing%sprx_Rgt_Bone'%i
		root_fing.AddBone( v_fingdst, c.siChainBonePin, 'fing%smid_Rgt_Bone'%i )
		root_fing.AddBone( v_fingend, c.siChainBonePin, 'fing%sdst_Rgt_Bone'%i )
		
		root_fing.Kinematics.Global.Transform = lm_fingprx.Kinematics.Global.Transform
		root_fing.Bones(0).Kinematics.Global.Transform = lm_fingprx.Kinematics.Global.Transform
		root_fing.Bones(1).Kinematics.Global.Transform = lm_fingmid.Kinematics.Global.Transform
		root_fing.Bones(2).Kinematics.Global.Transform = lm_fingdst.Kinematics.Global.Transform
		
		formatChain( root_fing, .2 )
		


	########################################
	# build spine
	#
	col.SetAsText( '%s.%s' % ( model_lm.Fullname,
							   dict_lm['spineBase']['None']) )
	lm_spine = col(0)

	col.SetAsText( '%s.%s' % ( model_lm.Fullname,
							   dict_lm['chestBase']['None']) )
	lm_chest = col(0)

	col.SetAsText( '%s.%s' % ( model_lm.Fullname,
							   dict_lm['neckBase']['None']) )
	lm_neck = col(0)

	col.SetAsText( '%s.%s' % ( model_lm.Fullname,
							   dict_lm['headBase']['None']) )
	lm_head = col(0)

	# duplicate the spine curve #
	crv_spine = xsi.Duplicate( lm_neck.parent )(0)
	mdl_rig.AddChild( crv_spine )

	v_spine  = XSIMath.CreateVector3()
	lm_spine.Kinematics.Global.Transform.GetTranslation( v_spine )
	v_chest  = XSIMath.CreateVector3()
	lm_chest.Kinematics.Global.Transform.GetTranslation( v_chest )
	v_neck  = XSIMath.CreateVector3()
	lm_neck.Kinematics.Global.Transform.GetTranslation( v_neck )
	
	# find the constraints #
	cns_chest = dispFix( lm_chest.Kinematics.Constraints(0) )
	perc_chest = cns_chest.Parameters( 'perc' ).Value
		
	cns_neck = dispFix( lm_neck.Kinematics.Constraints(0) )
	perc_neck = cns_neck.Parameters( 'perc' ).Value
	
	prop_spine = dispFix( crv_spine.Properties( 'RigSpineCurve' ) )
	num_lum = prop_spine.Parameters( 'lumbar' ).Value
	num_thr = prop_spine.Parameters( 'thoratic' ).Value
	num_crv = prop_spine.Parameters( 'cervical' ).Value
	
	inc_lum = perc_chest/num_lum
	inc_thr = (perc_neck-perc_chest)/num_thr
	inc_crv = (100-perc_neck)/num_crv
	
	# calculate the normal plain #
	v_plain = XSIMath.CreateVector3()
	v_sub1 = XSIMath.CreateVector3()
	v_sub2 = XSIMath.CreateVector3()
	v_sub1.Sub( v_chest, v_head )
	v_sub2.Sub( v_chest, v_neck )
	v_plain.Cross( v_sub1, v_sub2 )
		
	root_lum = None
	for i in xrange(num_lum):
#		xsi.logmessage( '%s %s %s %s' % ( i, perc_chest, inc_lum, inc_lum*(i+1) ) )
		
		# get the point on curve #
		crv = crv_spine.ActivePrimitive.Geometry.Curves(0)
		v_pos_end = crv.EvaluatePositionFromPercentage( 100 )[0]
		v_pos_start = crv.EvaluatePositionFromPercentage( 0 )[0]
		v_pos_cur = crv.EvaluatePositionFromPercentage( inc_lum*(i) )[0]
		v_pos_nxt = crv.EvaluatePositionFromPercentage( inc_lum*(i+1) )[0]

		if not root_lum:
		
			# build the chain #
			root_lum = mdl_rig.Add2DChain( v_pos_cur, v_pos_nxt, v_plain, c.si2DChainNormalRadian, 
											'lumbar%s_Mid_Chn'%(i+1) )
			root_lum = dispFix( root_lum )
			root_lum.effector.Name = 'lumbar%s_Mid_Eff'%(i+1)
			root_lum.Bones(0).Name = 'lumbar%s_Mid_Bone'%(i+1)
			
			cns = dispFix( root_lum.Kinematics.AddConstraint( 'Path', crv_spine, False ) )
			cns.Parameters( 'perc' ).Value = inc_lum*(i)
			
		else:
			bone = root_lum.AddBone( v_pos_nxt, c.siChainBonePin, 'lumbar%s_Mid_Bone'%(i+1) )
			cns = dispFix( bone.Kinematics.AddConstraint( 'Path', crv_spine, False ) )
			cns.Parameters( 'perc' ).Value = inc_lum*(i)
			
	cns = dispFix( root_lum.effector.Kinematics.AddConstraint( 'Path', crv_spine, False ) )
	cns.Parameters( 'perc' ).Value = perc_chest
	formatChain( root_lum, 0.75 )
		
	root_thr = None
	for i in xrange(num_thr):
		
		# get the point on curve #
		crv = crv_spine.ActivePrimitive.Geometry.Curves(0)
		v_pos_cur = crv.EvaluatePositionFromPercentage( perc_chest+(inc_thr*(i)) )[0]
		v_pos_nxt = crv.EvaluatePositionFromPercentage( perc_chest+(inc_thr*(i+1)) )[0]
		v_pos_end = crv.EvaluatePositionFromPercentage( 100 )[0]
		v_pos_start = crv.EvaluatePositionFromPercentage( 0 )[0]
		
		if not root_thr:
		
			# build the chain #
			root_thr = mdl_rig.Add2DChain( v_pos_cur, v_pos_nxt, v_plain, c.si2DChainNormalRadian, 
											'thorax%s_Mid_Chn'%(i+1) )
			root_thr = dispFix( root_thr )
			root_thr.effector.Name = 'thorax%s_Mid_Eff'%(i+1)
			root_thr.Bones(0).Name = 'thorax%s_Mid_Bone'%(i+1)
			
			
		else:
			bone = root_thr.AddBone( v_pos_nxt, c.siChainBonePin, 'thorax%s_Mid_Bone'%(i+1) )
	

	for i in xrange(num_thr):
		if i==0:
			cns = dispFix( root_thr.Kinematics.AddConstraint( 'Position', root_lum.effector, False ) )
#			cns = dispFix( root_thr.Kinematics.AddConstraint( 'Path', crv_spine, False ) )
#			cns.Parameters( 'perc' ).Value = perc_chest+(inc_thr*(i))
		else:
			cns = dispFix( root_thr.bones(i).Kinematics.AddConstraint( 'Path', crv_spine, False ) )
			cns.Parameters( 'perc' ).Value = perc_chest + (inc_thr*(i))
			
	cns = dispFix( root_thr.effector.Kinematics.AddConstraint( 'Path', crv_spine, False ) )
	cns.Parameters( 'perc' ).Value = perc_neck

	formatChain( root_thr, 0.75 )

	root_crv = None
	for i in xrange(num_crv):
#		xsi.logmessage( '%s %s %s %s' % ( i, perc_chest, inc_lum, inc_lum*(i+1) ) )
		
		# get the point on curve #
		crv = crv_spine.ActivePrimitive.Geometry.Curves(0)
		v_pos_cur = crv.EvaluatePositionFromPercentage( perc_neck+(inc_crv*(i)) )[0]
		v_pos_nxt = crv.EvaluatePositionFromPercentage( perc_neck+(inc_crv*(i+1)) )[0]
		v_pos_end = crv.EvaluatePositionFromPercentage( 100 )[0]
		v_pos_start = crv.EvaluatePositionFromPercentage( 0 )[0]
		
		if not root_crv:
		
			# build the chain #
			root_crv = mdl_rig.Add2DChain( v_pos_cur, v_pos_nxt, v_plain, c.si2DChainNormalRadian, 
											'cervical%s_Mid_Chn'%(i+1) )
			root_crv = dispFix( root_crv )
			root_crv.effector.Name = 'cervical%s_Mid_Eff'%(i+1)
			root_crv.Bones(0).Name = 'cervical%s_Mid_Bone'%(i+1)
			
		else:
			bone = root_crv.AddBone( v_pos_nxt, c.siChainBonePin, 'cervical%s_Mid_Bone'%(i+1) )
			
	for i in xrange(num_crv):
		if i==0:
			cns = dispFix( root_crv.Kinematics.AddConstraint( 'Position', root_thr.effector, False ) )
#			cns = dispFix( root_crv.Kinematics.AddConstraint( 'Path', crv_spine, False ) )
#			cns.Parameters( 'perc' ).Value = perc_neck + (inc_crv*(i))
		else:
			cns = dispFix( root_crv.bones(i).Kinematics.AddConstraint( 'Path', crv_spine, False ) )
			cns.Parameters( 'perc' ).Value = perc_neck + (inc_crv*(i))
			
	cns = dispFix( root_crv.effector.Kinematics.AddConstraint( 'Path', crv_spine, False ) )
	cns.Parameters( 'perc' ).Value = 100

	formatChain( root_crv, 0.75 )
		

	########################################
	# build arm left
	#
	col.SetAsText( '%s.%s' % ( model_lm.Fullname,
							   dict_lm['shoulder']['Lft']) )
	lm_lshldr = col(0)

	col.SetAsText( '%s.%s' % ( model_lm.Fullname,
							   dict_lm['scapulaBase']['Lft']) )
	lm_scapb = col(0)

	col.SetAsText( '%s.%s' % ( model_lm.Fullname,
							   dict_lm['scapulaMid']['Lft']) )
	lm_scapm = col(0)

	v_lshldr  = XSIMath.CreateVector3()
	v_lscapb  = XSIMath.CreateVector3()
	v_lscapm  = XSIMath.CreateVector3()
	lm_lshldr.Kinematics.Global.Transform.GetTranslation( v_lshldr )
	lm_scapb.Kinematics.Global.Transform.GetTranslation( v_lscapb )
	lm_scapm.Kinematics.Global.Transform.GetTranslation( v_lscapm )
	
	# calculate the normal plain #
	v_plain = XSIMath.CreateVector3()
	v_sub1 = XSIMath.CreateVector3()
	v_sub2 = XSIMath.CreateVector3()
	v_sub1.Sub( v_lscapb, v_lshldr )
	v_sub2.Sub( v_lscapb, v_lscapm )
	v_plain.Cross( v_sub2, v_sub1 )
	
	
	root_lscap = mdl_rig.Add2DChain( v_lscapb, v_lscapm, v_plain, c.si2DChainNormalRadian, 'scapula_Lft_Chn' )
	root_lscap = dispFix( root_lscap )
	root_lscap.effector.Name = 'scapula_Lft_Eff'
	root_lscap.Bones(0).Name = 'scapula1_Lft_Bone'
	root_lscap.AddBone( v_lshldr, c.siChainBonePin, 'scapula2_Lft_Bone' )
	
	
	formatChain( root_lscap )
	
		
def dispFix( obj ):	
	return win32com.client.dynamic.Dispatch( obj )
	
def formatChain( root, size=1 ):
	
	# hide the root and effector #
	root.Parameters( 'primary_icon' ).Value = 0
	root.effector.Parameters( 'primary_icon' ).Value = 0
	
	# step through each bone #
	for bone in root.Bones:
		# set the size #
		bone.size = size
		
		# set the color #
		disp = bone.AddProperty( 'Display Property' )
		disp.Parameters( 'wirecol' ).Value = 88
		
	# set the neutral pose #
	col = win32com.client.Dispatch( 'XSI.Collection' )
	col.Add( root )
	col.Add( root.effector )
	col.AddItems( root.Bones )
	
	xsi.SetNeutralPose( col.GetAsText().split(','), 'siSRT' )
	

def landmarks_Execute():

	Application.LogMessage("landmarks_Execute called")
	
	Application.UpdatePlugins()

	cp = xsi.ActiveSceneRoot.AddProperty( "CustomProperty", False, "Blah")
	stuff = cp.AddParameter3( 'Joint', c.siString )
	
	plo = cp.PPGLayout
	plo.AddGroup( "Legs" )
	plo.AddEnumControl( "Joint", 
						 [ "Thigh", "thigh",
						   "Shin", "shin", 
						   'Foot', 'foot', 
						   'Toe', 'toe' ],
						  "Legs",  
						  c.siControlRadio )
	plo.AddEnumControl( "Joint", 
						 [ "Upperarm", "upperarm",
						   "Forearm", "forearm", 
						   'Hand', 'hand' ],
						  "Arms",  
						  c.siControlRadio )
	plo.EndGroup()
	plo.AddButton( 'NewLandmark', 'New Landmark' )
	
	xsi.InspectObj( cp )
	
	plo.Language = "Python"
	plo.Logic = """
from win32com.client import constants as c
xsi = Application
def NewLandmark_OnClicked():
	xsi.logmessage( 'Click' )
	
	# get the currently insepected ppg #
	prop = PPG.Inspected(0)
	
	# get the joint value #
	joint = prop.Parameters( 'Joint' ).Value
	
	if not joint:
		xsi.logmessage( 'No Joint Selected', c.siError )
		return
		
	xsi.createLandmark( joint )
	
"""

	


	return true
